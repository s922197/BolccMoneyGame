<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤¾ç•œç”Ÿå­˜æˆ°ï¼šç†è²¡ Roguelike v5.9.3 (å„ªåŒ–è©é¨™å¡ç‰‡æ—¥èªŒ)</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #27ae60;
            --danger: #e74c3c;
            --warning: #f39c12;
            --bg: #ecf0f1;
            --card-bg: #fff;
            /* èª¿æ•´åŸºç¤å­—é«”å¤§å° */
            font-size: 18px; /* åŸºç¤å­—é«”æ”¾å¤§ */
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--primary);
            margin: 0;
            padding: 15px; /* å¢åŠ æ•´é«”é‚Šè· */
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }
        .container {
            max-width: 1400px; /* ç¨å¾®å¢åŠ æœ€å¤§å¯¬åº¦ */
            width: 100%;
        }
        
        /* æ¨™é¡Œèˆ‡æŒ‰éˆ•æ”¾å¤§ */
        #setup-screen h1 { font-size: 2.5em; }
        #setup-screen h3 { font-size: 1.5em; }
        #setup-screen p { font-size: 1.1em; }
        .confirm-btn, .secondary-btn {
            padding: 15px 50px;
            font-size: 1.4em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.1s;
            margin: 5px;
        }
        .confirm-btn {
            background: var(--accent);
            color: white;
            box-shadow: 0 4px 0 #1e8449;
        }
        .secondary-btn {
            background: #3498db;
            color: white;
            box-shadow: 0 4px 0 #2980b9;
        }
        .confirm-btn:active { transform: translateY(4px); box-shadow: none; }
        .secondary-btn:active { transform: translateY(4px); box-shadow: none; }
        .confirm-btn:disabled {
            background: #95a5a6;
            box-shadow: 0 4px 0 #7f8c8d;
            cursor: not-allowed;
            transform: translateY(0);
        }

        /* å„€è¡¨æ¿ - å¼·åˆ¶å°é½Šå’Œç­‰å¯¬ */
        .dashboard {
            display: flex;
            justify-content: space-between;
            gap: 15px; 
            margin-bottom: 20px;
        }
        .player-stats {
            background: var(--card-bg);
            padding: 15px 20px; 
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            
            flex-basis: 0;
            flex-grow: 1; 
            
            border-top: 5px solid #bdc3c7;
            transition: all 0.3s;
            position: relative;
        }
        .player-stats h3 { font-size: 1.4em; margin-top: 0; margin-bottom: 10px; }
        .player-stats.active {
            border-top-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.2);
        }
        
        /* æ•¸å€¼é¡¯ç¤º */
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0; 
            font-size: 1.1em; 
            align-items: center;
        }
        .money { 
            color: var(--accent); 
            font-weight: bold; 
            font-family: monospace; 
            font-size: 1.2em; 
        }
        .total-asset {
            color: #e67e22;
            font-weight: bold; 
            font-family: monospace; 
            font-size: 1.2em; 
        }
        .debt { color: var(--danger); font-weight: bold; }
        
        /* å¥åº·æ¢ */
        .hp-bar-bg { width: 100px; height: 10px; background: #ddd; border-radius: 5px; overflow: hidden; }
        .hp-bar-fill { height: 100%; transition: width 0.5s, background 0.5s; }

        /* éŠæˆ²è³‡è¨Šèˆ‡éšæ®µ */
        .phase-indicator {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.4em; 
            font-weight: bold;
            color: #d35400;
            margin: 15px 0;
            background: #fad7a0;
            padding: 8px 15px; /* èª¿æ•´ padding ä»¥å®¹ç´è¨ˆæ™‚å™¨ */
            border-radius: 5px;
        }
        .phase-center {
            text-align: center;
            flex-grow: 1;
        }
        /* æ–°å¢ï¼šè¨ˆæ™‚å™¨æ¨£å¼ */
        #timer-display {
            font-size: 1.8em;
            color: var(--danger);
            min-width: 60px; /* ç¢ºä¿å¯¬åº¦ç©©å®š */
            text-align: right;
        }


        /* å¡ç‰Œå€åŸŸ - ç¢ºä¿å–®è¡Œé¡¯ç¤º */
        .cards-area {
            display: flex; /* æ”¹ç‚º Flex ä½ˆå±€ */
            gap: 20px;
            margin-bottom: 20px;
            justify-content: space-between; /* å‡å‹»åˆ†ä½ˆ */
        }
        .card {
            background: var(--card-bg);
            border: 3px solid #eee; /* åŠ ç²—é‚Šæ¡† */
            border-radius: 8px;
            padding: 15px; 
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 180px; 
            position: relative;

            flex-basis: 0; /* ç¢ºä¿ç­‰å¯¬ */
            flex-grow: 1; 
            flex-shrink: 1;
            min-width: 0; /* å…è¨±ç¸®å° */
        }
        /* ç‰¹æ®Šï¼šé«˜é¢¨éšª/è©é¨™å¡ç‰Œæ¨£å¼ */
        .card.scam {
            border: 4px solid var(--danger);
            background: #fffafa;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.4);
        }
        .card.scam .card-title { color: var(--danger); }


        .card:hover { transform: translateY(-3px); border-color: #bdc3c7; }
        
        /* æ–°å¢ï¼šé¸ä¸­ç‹€æ…‹ */
        .card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.7);
            transform: translateY(-5px);
        }
        .card.scam.selected {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.7);
        }


        /* ç¦ç”¨çš„å¡ç‰Œ */
        .card.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(1);
            cursor: not-allowed;
            border-color: #f1f1f1;
        }
        /* ç‰¹æ®Šï¼šå¼·åˆ¶æ²»ç—…è­¦ç¤º */
        .card.force-heal {
            border-color: var(--danger);
            background: #fdf5f5;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
        }
        .card.force-heal:hover {
            transform: translateY(-3px);
            border-color: var(--danger);
        }


        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        .card-title { font-weight: bold; color: #2980b9; font-size: 1.3em; line-height: 1.2; }
        .card-desc { font-size: 1em; color: #555; line-height: 1.4; flex-grow: 1; }
        
        /* æ¨™ç±¤ */
        .tag {
            font-size: 0.8em; 
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            display: inline-block;
            margin-top: 5px;
        }
        .tag-job { background: #3498db; }
        .tag-risk-low { background: #27ae60; }
        .tag-risk-mid { background: #f39c12; }
        .tag-risk-high { background: #c0392b; }
        .tag-scam { background: #8e44ad; }
        .tag-special { background: #95a5a6; }
        .tag-special-danger { background: var(--danger); }

        /* äº‹ä»¶æ—¥èªŒå„ªåŒ– */
        .log-area {
            background: #fff;
            padding: 20px; 
            border-radius: 8px;
            height: 200px; 
            overflow-y: auto;
            border: 1px solid #ddd;
            font-family: monospace;
            font-size: 1.1em; 
        }
        .log-area h3 { font-size: 1.3em; }
        .log-entry { margin-bottom: 7px; border-bottom: 1px dashed #eee; padding-bottom: 4px; }
        .log-turn { color: #fff; background: #e67e22; padding: 4px 8px; border-radius: 3px; font-weight: bold; }
        .log-bad { color: #c0392b; font-weight: bold; }
        .log-good { color: #27ae60; font-weight: bold; }
        .log-scam { color: #8e44ad; font-weight: bold; } /* è©é¨™logé¡è‰² */


        /* ç‹€æ…‹æ–‡å­—å°å­— */
        .status-text { font-size: 0.9em; color: #7f8c8d; margin-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>

<div class="container">
    <div id="setup-screen" style="text-align: center; margin-top: 50px;">
        <h1>ğŸ¥ ç¤¾ç•œç”Ÿå­˜æˆ° Roguelike</h1>
        <h3>ç†è²¡ x å¥åº· x éš¨æ©Ÿäº‹ä»¶</h3>
        <div style="background: white; padding: 20px; border-radius: 10px; display: inline-block; text-align: left;">
            <p>âœ… <b>ç›®æ¨™ï¼š</b>20 è¼ªå¾Œç¸½è³‡ç”¢æœ€é«˜è€…ç²å‹</p>
            <p>âœ… <b>è¦å‰‡ï¼š</b>æ¯è¼ªå¾ 5 å€‹é¸é …ä¸­**é¸æ“‡ 1 æˆ– 2 å€‹**åŸ·è¡Œ</p>
            <p>â±ï¸ **æ™‚é–“é™åˆ¶ï¼š** éš¨è‘—éŠæˆ²é€²å±•ï¼Œæ±ºç­–æ™‚é–“å°‡é€æ¼¸ç¸®çŸ­ï¼</p>
            <p>ğŸš¨ **é«˜é¢¨éšªå¡ç‰‡ï¼š** éš¨æ©Ÿå‡ºç¾**è©é¨™/é«˜é¢¨éšªæŠ•è³‡**å¡ç‰‡ï¼ (é‡‘é¡å·²éš±è—)</p>
            <p style="color: #c0392b;">**ç‰ˆæœ¬æ›´æ–° v5.9.3ï¼š** **å„ªåŒ–è©é¨™å¡ç‰‡é‚è¼¯**ï¼Œè®“æ—¥èªŒæ˜ç¢ºé¡¯ç¤ºå¯¦éš›æå¤±é‡‘é¡ï¼Œä¸¦å¢åŠ æƒ…å¢ƒæè¿°çš„éš¨æ©Ÿæ€§ã€‚</p>
        </div>
        <br><br>
        <button class="confirm-btn" onclick="startGame()">é–‹å§‹å°æŠ—</button>
    </div>
    
    <div id="game-screen" style="display: none;">
        <div class="phase-indicator">
            <span id="timer-display">--</span>
            <div class="phase-center">
                <span id="turn-display">æº–å‚™ä¸­...</span> | <span id="phase-msg"></span>
            </div>
        </div>

        <div class="dashboard">
            <div class="player-stats" id="p1-stats">
                <h3>ğŸ‘¨â€ğŸ’¼ A çµ„</h3>
                <div class="stat-row">
                    <span>ç¾é‡‘/å­˜æ¬¾</span>
                    <span><span class="money" id="p1-cash">$100</span> / <span class="money" id="p1-bank">$0</span></span>
                </div>
                <div class="stat-row">
                    <span>æŠ•è³‡è³‡ç”¢ (ä¼°)</span>
                    <span class="money" id="p1-investment-asset">$0</span>
                </div>
                <div class="stat-row">
                    <span>ç¸½è³‡ç”¢ (ä¼°ç®—)</span>
                    <span class="total-asset" id="p1-total-asset">$100</span>
                </div>
                <div class="stat-row">
                    <span>å¥åº·å€¼</span>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <span id="p1-hp-text">100</span>
                        <div class="hp-bar-bg"><div class="hp-bar-fill" id="p1-hp-bar" style="width:100%; background:#27ae60;"></div></div>
                    </div>
                </div>
                <div class="stat-row">åˆ©ç‡: <span class="money" style="color:#8e44ad" id="p1-rate">1.0%</span></div>
                <div class="status-text" id="p1-status">ç„¡å·¥ä½œ</div>
            </div>

            <div class="player-stats" id="p2-stats">
                <h3>ğŸ‘©â€ğŸ’» B çµ„</h3>
                <div class="stat-row">
                    <span>ç¾é‡‘/å­˜æ¬¾</span>
                    <span><span class="money" id="p2-cash">$100</span> / <span class="money" id="p2-bank">$0</span></span>
                </div>
                <div class="stat-row">
                    <span>æŠ•è³‡è³‡ç”¢ (ä¼°)</span>
                    <span class="money" id="p2-investment-asset">$0</span>
                </div>
                <div class="stat-row">
                    <span>ç¸½è³‡ç”¢ (ä¼°ç®—)</span>
                    <span class="total-asset" id="p2-total-asset">$100</span>
                </div>
                <div class="stat-row">
                    <span>å¥åº·å€¼</span>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <span id="p2-hp-text">100</span>
                        <div class="hp-bar-bg"><div class="hp-bar-fill" id="p2-hp-bar" style="width:100%; background:#27ae60;"></div></div>
                    </div>
                </div>
                <div class="stat-row">åˆ©ç‡: <span class="money" style="color:#8e44ad" id="p2-rate">1.0%</span></div>
                <div class="status-text" id="p2-status">ç„¡å·¥ä½œ</div>
            </div>
        </div>

        <div id="cards-container" class="cards-area" style="justify-content: center;"></div>

        <div class="action-area" style="text-align: center; margin-top: 20px;">
            <button class="confirm-btn" id="confirm-btn" onclick="confirmAction()" disabled>ç¢ºèªè¡Œå‹• (è«‹é¸æ“‡ 1-2 å¼µå¡)</button>
        </div>

        <h3>ğŸ“ äº‹ä»¶æ—¥èªŒ</h3>
        <div class="log-area" id="game-log"></div>
    </div>
</div>

<script>
const CONFIG = {
    maxTurns: 20,
    startCash: 100,
    livingCost: 30, 
    titheRate: 0.1,
    baseRate: 0.01,
    startHp: 100,
    maxHp: 100,
    safeHours: 8, 
    overworkPenalty: 3, 
    lowHpThreshold: 30, 
    minSickCost: 50, 
    turnSalaryIncrease: 0.02,
    scamLossRange: [1000, 3000], 
    // --- æ™‚é–“é™åˆ¶é…ç½® ---
    timeLimits: [
        { endTurn: 5, time: 60 }, 
        { endTurn: 10, time: 40 }, 
        { endTurn: 15, time: 30 }, 
        { endTurn: 20, time: 20 } 
    ]
};

let gameState = {
    turn: 1,
    phase: 'p1_choice', // p1_choice, p2_choice, processing
    players: [],
    currentCards: [],
    selectedIndices: [], 
    maxSelections: 1,
    selectionCount: 0, // å·²åŸ·è¡Œè¡Œå‹•è¨ˆæ•¸ (ä¸»è¦ç”¨æ–¼å­˜æ¬¾å’Œè©é¨™ï¼Œé€™äº›æœƒç«‹å³åŸ·è¡Œä¸¦è¨ˆæ•¸)
    // --- è¨ˆæ™‚å™¨ç‹€æ…‹ ---
    timer: null,
    timeLeft: 0,
    // --- æ­·å²æ•¸æ“š (ä¿ç•™ç©ºé™£åˆ—ï¼Œä¸å„²å­˜åˆ° LocalStorage) ---
    history: [] 
};


// --- éŠæˆ²é–‹å§‹æµç¨‹ ---

function createPlayer(name) {
    return {
        name: name,
        id: name === 'A çµ„' ? 0 : 1, 
        cash: CONFIG.startCash,
        bank: 0,
        rate: CONFIG.baseRate,
        tempRateBoost: { amount: 0, turnsLeft: 0 }, 
        hp: CONFIG.startHp,
        stableJob: null, 
        partTimeJobs: [], 
        investments: [],
        lockedSavings: [], 
        stocks: [], 
        roundIncome: 0,
        sicknessCost: 0 
    };
}

function startGame() {
    document.getElementById('setup-screen').style.display = 'none';
    document.getElementById('game-screen').style.display = 'block';
    
    gameState.turn = 1;
    gameState.players = [createPlayer('A çµ„'), createPlayer('B çµ„')];
    gameState.history = []; // æ¸…ç©ºæœ¬æ¬¡éŠæˆ²æ­·å²è¨˜éŒ„
    
    log("=== éŠæˆ²é–‹å§‹ ===", 'turn');
    log("ç¬¬ 1 è¼ª (T1) åªèƒ½é¸æ“‡ 1 å¼µå·¥ä½œå¡ã€‚ç”Ÿæ´»è²»èª¿æ•´ç‚º $30ã€‚");
    
    startPlayerTurn(0);
}

// --- è¨ˆæ™‚å™¨åŠŸèƒ½ ---
function getTimeLimit(turn) {
    // ç§»é™¤ç‰¹æ®Šäº‹ä»¶çš„å›ºå®šæ™‚é–“
    for (const limit of CONFIG.timeLimits) {
        if (turn <= limit.endTurn) {
            return limit.time;
        }
    }
    return CONFIG.timeLimits[CONFIG.timeLimits.length - 1].time;
}

function startTimer(duration) {
    clearInterval(gameState.timer);
    gameState.timeLeft = duration;
    const timerDisplay = document.getElementById('timer-display');
    timerDisplay.innerText = gameState.timeLeft;
    
    timerDisplay.style.color = 'var(--danger)'; 
    if (duration > 40) timerDisplay.style.color = 'var(--warning)';

    gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        timerDisplay.innerText = gameState.timeLeft;
        
        if (gameState.timeLeft <= 10) {
            timerDisplay.style.color = 'var(--danger)';
        }

        if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timer);
            log(`ğŸš¨ æ™‚é–“åˆ°ï¼è‡ªå‹•åŸ·è¡Œç•¶å‰è¡Œå‹•ã€‚`, 'bad');
            confirmAction(false, true); 
        }
    }, 1000);
}

function stopTimer() {
    clearInterval(gameState.timer);
    document.getElementById('timer-display').innerText = '--';
}


// --- éŠæˆ²æµç¨‹æ§åˆ¶ ---
function startPlayerTurn(playerIdx) {
    if (gameState.turn > CONFIG.maxTurns) {
        endGame();
        return;
    }

    const playerPrefix = playerIdx === 0 ? 'p1' : 'p2';
    const player = gameState.players[playerIdx];

    // æ­£å¸¸å›åˆ
    gameState.phase = `${playerPrefix}_choice`;
    if (gameState.turn === 1) {
        gameState.maxSelections = 1; 
    } else {
        gameState.maxSelections = 2; 
    }
    generateCards(playerIdx);
    
    gameState.selectedIndices = []; 
    gameState.selectionCount = 0; // é‡ç½®å·²åŸ·è¡Œè¡Œå‹•è¨ˆæ•¸
    
    updateUI();
    
    const btn = document.getElementById('confirm-btn');
    btn.disabled = true;
    btn.innerText = `ç¢ºèªè¡Œå‹• (è«‹é¸æ“‡ 1-${gameState.maxSelections} å¼µå¡)`;

    // ç¢ºä¿æ‰€æœ‰å¡ç‰‡éƒ½å·²é‡è¨­
    document.querySelectorAll('.card').forEach(card => card.classList.remove('disabled', 'selected', 'force-heal'));

    const timeLimit = getTimeLimit(gameState.turn);
    startTimer(timeLimit); 
}

function handleCardClick(index) {
    const btn = document.getElementById('confirm-btn');
    const cardElement = document.getElementById(`card-${index}`);
    const card = gameState.currentCards[index];
    const playerIdx = gameState.phase.startsWith('p1') ? 0 : 1;
    const player = gameState.players[playerIdx];

    // 1. ç–¾ç—…å¼·åˆ¶é¸æ“‡æª¢æŸ¥ 
    if (player.hp <= CONFIG.lowHpThreshold) {
        if (card.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯') {
            gameState.selectedIndices = [index];
            confirmAction(); 
            return;
        }
        return;
    }

    // 2. å­˜æ¬¾ç‰¹æ®Šè™•ç†ï¼šå½ˆå‡º Prompt 
    if (card.title === 'ğŸ’° å½ˆæ€§å­˜æ¬¾') {
        if (gameState.selectionCount + gameState.selectedIndices.length >= gameState.maxSelections) {
            log(`âš ï¸ å­˜æ¬¾è¡Œå‹•ä¸èƒ½è¶…éæœ¬è¼ªé¸æ“‡ä¸Šé™ï¼`, 'bad');
            return;
        }

        stopTimer(); 
        document.querySelectorAll('.card').forEach(c => c.classList.add('disabled'));

        let input = prompt("è«‹è¼¸å…¥å­˜æ¬¾æ¯”ä¾‹ï¼š20 (20%) / 50 (50%) / ALL (å…¨éƒ¨)");
        
        // é‡æ–°å•Ÿç”¨æœªé¸ä¸­çš„å¡ç‰‡
        document.querySelectorAll('.card').forEach((c, i) => {
            if (!gameState.selectedIndices.includes(i) && c.id !== `card-${index}`) {
                c.classList.remove('disabled');
            }
        });
        
        // é‡æ–°å•Ÿå‹•è¨ˆæ™‚å™¨
        startTimer(gameState.timeLeft); 

        if (input) {
            input = input.toUpperCase().trim();
            let amtToDeposit = 0;
            if (input === 'ALL') {
                amtToDeposit = player.cash;
            } else {
                const percentage = parseInt(input);
                if (percentage === 20 || percentage === 50) {
                    amtToDeposit = Math.floor(player.cash * (percentage / 100));
                }
            }

            if (amtToDeposit > 0) {
                const result = card.effect(player, amtToDeposit); 
                log(result, 'good'); // å­˜æ¬¾æˆåŠŸæ—¥èªŒ
                gameState.selectionCount++;
                updateUI(); // å¿…é ˆæ›´æ–° UI ç¢ºä¿è³‡ç”¢é¡¯ç¤ºæ­£ç¢º

                // ç«‹å³ç¦ç”¨å­˜æ¬¾å¡ï¼Œé˜²æ­¢é‡è¤‡é¸æ“‡
                cardElement.classList.add('disabled');
                cardElement.onclick = null;


                let currentSelected = gameState.selectionCount + gameState.selectedIndices.length;
                if (currentSelected < gameState.maxSelections) {
                    log(`âœ… ${player.name} å®Œæˆå­˜æ¬¾ï¼Œé‚„å¯å†é¸ ${gameState.maxSelections - currentSelected} å¼µå¡ç‰‡ã€‚`);
                    btn.disabled = false;
                    btn.innerText = `ç¢ºèªè¡Œå‹• (å·²é¸ ${currentSelected} / ${gameState.maxSelections})`;
                } else {
                    confirmAction(true); 
                }
                return;
            }
        }
        log(`âš ï¸ ${player.name} å–æ¶ˆæˆ–ç„¡æ•ˆçš„å­˜æ¬¾é¸æ“‡ã€‚`, 'bad');
        return;
    }
    
    // 3. è©é¨™å¡ç‰‡ç‰¹æ®Šè™•ç†ï¼šç«‹å³åŸ·è¡Œä¸¦ç¦ç”¨ (ä¿®æ­£é‚è¼¯)
    let isScam = card.scamCost !== undefined;
    if (isScam) {
        if (gameState.selectionCount + gameState.selectedIndices.length >= gameState.maxSelections) {
            log(`âš ï¸ è©é¨™è¡Œå‹•ä¸èƒ½è¶…éæœ¬è¼ªé¸æ“‡ä¸Šé™ï¼`, 'bad');
            return;
        }
        
        // **ä¿®æ­£é»:** å‘¼å« effect å–å¾—æ—¥èªŒçµæœ
        const result = card.effect(player, card); 
        log(result, 'scam'); // é¡¯ç¤ºæå¤±çµæœ
        gameState.selectionCount++;

        // ç«‹å³ç¦ç”¨æ­¤å¡ç‰‡ï¼Œé˜²æ­¢é‡è¤‡é»æ“Š
        cardElement.classList.add('disabled');
        cardElement.onclick = null;
        
        // å¿…é ˆæ›´æ–° UI ç¢ºä¿è³‡ç”¢é¡¯ç¤ºæ­£ç¢º (ç¾é‡‘/å­˜æ¬¾)
        updateUI(); 

        let currentSelected = gameState.selectionCount + gameState.selectedIndices.length;
        if (currentSelected < gameState.maxSelections) {
            log(`âœ… ${player.name} å·²åŸ·è¡Œè©é¨™è¡Œå‹•ï¼Œé‚„å¯å†é¸ ${gameState.maxSelections - currentSelected} å¼µå¡ç‰‡ã€‚`);
            btn.disabled = false;
            btn.innerText = `ç¢ºèªè¡Œå‹• (å·²é¸ ${currentSelected} / ${gameState.maxSelections})`;
            renderCards(false); // é‡æ–°æ¸²æŸ“å¡ç‰‡ç‹€æ…‹ï¼Œç¢ºä¿è¦–è¦ºä¸Šç¦ç”¨
        } else {
            // é”åˆ°ä¸Šé™å¾Œï¼Œç«‹å³çµç®—
            confirmAction(true); 
        }
        return;
    }


    // 4. æ­£å¸¸é¸æ“‡é‚è¼¯
    const idx = gameState.selectedIndices.indexOf(index);

    if (idx > -1) {
        gameState.selectedIndices.splice(idx, 1);
        cardElement.classList.remove('selected');
    } else {
        if (gameState.selectionCount + gameState.selectedIndices.length < gameState.maxSelections) {
            gameState.selectedIndices.push(index);
            cardElement.classList.add('selected');
        } else {
            log(`âš ï¸ æœ€å¤šåªèƒ½é¸æ“‡ ${gameState.maxSelections - gameState.selectionCount} å¼µå¡ç‰‡ï¼`, 'bad');
            return;
        }
    }
    
    let currentSelected = gameState.selectionCount + gameState.selectedIndices.length;
    if (currentSelected >= 1) {
        btn.disabled = false;
        btn.innerText = `ç¢ºèªè¡Œå‹• (${currentSelected} / ${gameState.maxSelections})`;
    } else {
        btn.disabled = true;
        btn.innerText = `ç¢ºèªè¡Œå‹• (è«‹é¸æ“‡ 1-${gameState.maxSelections} å¼µå¡)`;
    }
}

/**
 * ç¢ºèªè¡Œå‹• (åŒ…æ‹¬è¶…æ™‚)
 */
function confirmAction(isQuickAction = false, isTimeout = false) {
    stopTimer(); 

    const playerIdx = gameState.phase.startsWith('p1') ? 0 : 1;
    const player = gameState.players[playerIdx];

    const totalSelected = gameState.selectionCount + gameState.selectedIndices.length;
    let selectedCardNames = [];
    
    // --- è¶…æ™‚æˆ–é¸æ“‡æ•¸é‡æª¢æŸ¥ ---
    if (isTimeout && totalSelected === 0) {
        // æ­£å¸¸å›åˆè¶…æ™‚è™•ç†
        log(`${player.name} å› è¶…æ™‚æœªé¸æ“‡ï¼Œæœ¬è¼ªè¡Œå‹•è·³éã€‚`, 'turn');
        recordHistory(player, ['è¶…æ™‚/è·³é']); 
        setTimeout(() => nextPhase(playerIdx), 500); 
        return;
    }

    if (!isQuickAction && !isTimeout && (totalSelected < 1 || totalSelected > gameState.maxSelections)) {
         log(`âš ï¸ ${player.name} å¿…é ˆé¸æ“‡ 1 åˆ° ${gameState.maxSelections} å¼µå¡ç‰‡ï¼`, 'bad');
         startTimer(gameState.timeLeft); 
         return;
    }
    
    document.getElementById('confirm-btn').disabled = true;
    document.querySelectorAll('.card').forEach(card => card.classList.add('disabled'));
    
    let executionLog = `${player.name} åŸ·è¡Œäº† ${totalSelected} é …è¡Œå‹•: `;
    let results = [];
    
    // --- åŸ·è¡Œè¡Œå‹• (åƒ…åŸ·è¡Œ selectedIndices ä¸­çš„) ---
    gameState.selectedIndices.forEach(index => {
        const card = gameState.currentCards[index];
        const result = card.effect(player);
        results.push(`[${card.title}] - ${result}`);
        selectedCardNames.push(card.title);
        gameState.selectionCount++; 
    });
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ quickAction (å­˜æ¬¾/è©é¨™) å·²ç¶“åŸ·è¡Œä¸¦è¨ˆæ•¸ (selectionCount > 0)
    if (gameState.selectionCount > gameState.selectedIndices.length) {
        gameState.currentCards.forEach((card, index) => {
            const isScam = card.scamCost !== undefined;
            const isDeposit = card.title === 'ğŸ’° å½ˆæ€§å­˜æ¬¾';
            const isExecuted = document.getElementById(`card-${index}`).classList.contains('disabled') && !gameState.selectedIndices.includes(index);

            if ((isScam || isDeposit) && isExecuted) {
                if (!selectedCardNames.includes(card.title)) {
                    selectedCardNames.unshift(card.title); 
                }
            }
        });
    }

    // è™•ç†æ—¥èªŒ
    if (results.length > 0) {
        log(executionLog + results.join(' | '));
    }
    
    recordHistory(player, selectedCardNames);

    gameState.selectedIndices = [];
    
    // å¿…é ˆæ›´æ–° UI ç¢ºä¿è³‡ç”¢é¡¯ç¤ºæ­£ç¢º
    updateUI(); 

    // æ­£å¸¸å›åˆè™•ç†å®Œç•¢ï¼Œåˆ‡æ›åˆ°ä¸‹ä¸€ä½ç©å®¶æˆ–çµç®—
    setTimeout(() => nextPhase(playerIdx), 500);
}

function nextPhase(playerIdx) {
    if (playerIdx === 0) {
        // å¾ A çµ„ (0) åˆ‡æ›åˆ° B çµ„ (1)
        startPlayerTurn(1); 
    } else {
        // å¾ B çµ„ (1) åˆ‡åˆ‡æ›åˆ°çµç®—
        gameState.phase = 'processing';
        updateUI();
        document.getElementById('cards-container').innerHTML = '<h3 style="text-align:center;width:100%;color:#aaa;">çµç®—ä¸­...</h3>';
        setTimeout(processTurn, 800); 
    }
}

// --- æ•¸æ“šè¿½è¹¤ (ç•¥) ---
function recordHistory(player, actions) {
    const asset = getAssets(player, true);
    
    gameState.history.push({
        turn: gameState.turn,
        player: player.name,
        cash: player.cash,
        bank: player.bank,
        totalAsset: asset,
        hp: Math.floor(player.hp),
        sicknessCost: player.sicknessCost,
        stableJob: player.stableJob ? player.stableJob.name : 'ç„¡',
        partTimeCount: player.partTimeJobs.length,
        actions: actions.join(';')
    });
}

/**
 * æ ¸å¿ƒæ‰£æ¬¾å‡½æ•¸ï¼šå„ªå…ˆæ‰£é™¤ç¾é‡‘ï¼Œç¾é‡‘ä¸è¶³å‰‡æ‰£é™¤å­˜æ¬¾
 * é©ç”¨æ–¼**æ­£å¸¸å¡ç‰‡æˆæœ¬**ï¼Œç¢ºä¿è³‡ç”¢ç¸½é¡ä¸æœƒåœ¨è¡Œå‹•éšæ®µè®Šè² ã€‚
 * @param {object} p - ç©å®¶å°è±¡
 * @param {number} cost - éœ€æ”¯ä»˜çš„æˆæœ¬
 * @returns {string} æ‰£æ¬¾çµæœæè¿°
 */
function applyPayment(p, cost) {
    let actualCost = cost;
    let bankDeduction = 0;

    if (p.cash >= actualCost) {
        p.cash -= actualCost;
        return `æˆåŠŸæ”¯ä»˜ $${actualCost} (ç¾é‡‘æ”¯ä»˜)`;
    } else {
        let shortage = actualCost - p.cash;
        p.cash = 0;
        
        // å˜—è©¦å¾å­˜æ¬¾ä¸­æ‰£é™¤
        if (p.bank >= shortage) {
            p.bank -= shortage;
            bankDeduction = shortage;
            return `æˆåŠŸæ”¯ä»˜ $${actualCost} (ç¾é‡‘+å­˜æ¬¾æ”¯ä»˜$${bankDeduction})`;
        } else {
            // æ­£å¸¸å›åˆå¡ç‰‡ä¸å…è¨±è³‡ç”¢ç¸½é¡ï¼ˆç¾é‡‘+å­˜æ¬¾ï¼‰è®Šç‚ºè² æ•¸
            return 'è³‡ç”¢ç¸½é¡ä¸è¶³ï¼Œäº¤æ˜“å–æ¶ˆ (æ‡‰å·²åœ¨UIç¦ç”¨)';
        }
    }
}

/**
 * æ ¸å¿ƒæå¤±å‡½æ•¸ï¼šå„ªå…ˆæ‰£é™¤ç¾é‡‘ï¼Œç¾é‡‘ä¸è¶³å‰‡æ‰£é™¤å­˜æ¬¾
 * é©ç”¨æ–¼**å¼·åˆ¶æå¤±æˆ–è©é¨™äº‹ä»¶**ï¼Œ**å…è¨±å­˜æ¬¾è®Šç‚ºè² å‚µ**ã€‚
 * @param {object} p - ç©å®¶å°è±¡
 * @param {number} loss - éœ€æ”¯ä»˜çš„æå¤±é¡åº¦
 * @returns {number} å¯¦éš›æå¤±é¡åº¦
 */
function applyLoss(p, loss) {
    let actualLoss = loss;
    
    if (p.cash >= actualLoss) {
        p.cash -= actualLoss;
    } else {
        let shortage = actualLoss - p.cash;
        p.cash = 0;
        // ä¸æª¢æŸ¥å­˜æ¬¾æ˜¯å¦è¶³å¤ ï¼Œå…è¨±å­˜æ¬¾ç‚ºè²  (å³ç”¢ç”Ÿå‚µå‹™)
        p.bank -= shortage;
    }
    return actualLoss;
}


// --- å¡ç‰Œç”Ÿæˆå™¨ (æ–°å¢è©é¨™äº‹ä»¶) ---
function getDynamicPay(basePay) {
    if (gameState.turn === 1) return basePay;
    const increaseFactor = 1 + (gameState.turn - 1) * CONFIG.turnSalaryIncrease;
    return Math.floor(basePay * increaseFactor / 10) * 10;
}
function getCardCost(card) {
    // è©é¨™å¡çš„æˆæœ¬ now å„²å­˜åœ¨ card.scamCost å±¬æ€§ä¸­ï¼Œä¸è®“ UI é¡¯ç¤º cost
    if (card.scamCost !== undefined) return 0; 
    
    // å¦‚æœå¡ç‰‡æœ¬èº«å·²ç¶“å®šç¾©äº† costï¼Œå‰‡ä½¿ç”¨å®ƒ
    if (card.cost !== undefined && card.cost > 0) return card.cost;
    
    switch(card.title) {
        case 'ğŸ”’ å®šæœŸå­˜æ¬¾':
        case 'ğŸ¦ è—ç±Œè‚¡æŠ•è³‡':
        case 'ğŸš€ çŸ­æœŸæŠ•è³‡æ©Ÿæœƒ':
             // è®€å–æè¿°ä¸­çš„æŠ•å…¥é‡‘é¡ä½œç‚ºæˆæœ¬
             const match = card.desc.match(/æŠ•å…¥ \$(\d+)/) || card.desc.match(/é–å®šç¾é‡‘ \$(\d+)/);
            return match ? parseInt(match[1]) : 0;
        case 'ğŸ¤“ ç†è²¡è¬›åº§':
        case 'ğŸ§˜ æ·±åº¦ä¼‘æ¯':
             // ä¼‘æ¯å’Œè¬›åº§çš„æˆæœ¬åœ¨ generator ä¸­å‹•æ…‹è¨ˆç®—æˆ–å®šç¾©
             return card.cost; 
        default:
            return 0;
    }
}

const generators = {
    jobStableStandard: () => {
        const basePay = 200;
        const pay = getDynamicPay(basePay);
        return {
            title: 'ğŸ’¼ ä¸€èˆ¬è·å“¡', tag: 'ç©©å®šå·¥ä½œ', desc: `æ¨™æº–å·¥æ™‚ **8 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`,
            effect: (p) => { p.stableJob = { name: 'ä¸€èˆ¬è·å“¡', pay: pay, hours: 8, desc: '8hr/æ—¥' }; return 'ç²å¾—ç©©å®šå·¥ä½œ (8hr/æ—¥)'; }
        };
    },
    jobStableShift: () => {
        const basePay = 300;
        const pay = getDynamicPay(basePay);
        return {
            title: 'ğŸ­ ç”¢ç·šä½œæ¥­å“¡', tag: 'åšäºŒä¼‘äºŒ', desc: `æ¯æ—¥ **10 å°æ™‚**ã€‚é«˜è–ªä½†æœ‰éå‹é¢¨éšªã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`,
            effect: (p) => { p.stableJob = { name: 'ä½œæ¥­å“¡(åšäºŒä¼‘äºŒ)', pay: pay, hours: 10, desc: '10hr/æ—¥(å‡)' }; return 'ç²å¾—é«˜å·¥æ™‚å·¥ä½œ (10hr/æ—¥)'; }
        };
    },
    jobStableOvertime: () => {
        const basePay = 450;
        const pay = getDynamicPay(basePay);
        return {
            title: 'ğŸ’» è²¬ä»»åˆ¶å·¥ç¨‹å¸«', tag: 'çˆ†è‚', desc: `æ¯æ—¥ **12 å°æ™‚**ã€‚æ¥µé«˜æ”¶å…¥ä½†å¥åº·æ‰£æåš´é‡ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`,
            effect: (p) => { p.stableJob = { name: 'è²¬ä»»åˆ¶å·¥ç¨‹å¸«', pay: pay, hours: 12, desc: '12hr/æ—¥' }; return 'ç²å¾—çˆ†è‚å·¥ä½œ (12hr/æ—¥)'; }
        };
    },
    jobStableLow: () => {
        const basePay = 150;
        const pay = getDynamicPay(basePay);
        return {
            title: 'ğŸ›’ ä¾¿åˆ©å•†åº—åº—å“¡', tag: 'ä½è–ª', desc: `æ¨™æº–å·¥æ™‚ **8 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`,
            effect: (p) => { p.stableJob = { name: 'ä¾¿åˆ©å•†åº—åº—å“¡', pay: pay, hours: 8, desc: '8hr/æ—¥' }; return 'ç²å¾—ç©©å®šä½è–ªå·¥ä½œ (8hr/æ—¥)'; }
        };
    },
    jobStableMed: () => {
        const basePay = 250;
        const pay = getDynamicPay(basePay);
        return {
            title: 'ğŸ‘¨â€ğŸ« è£œç¿’ç­è€å¸«', tag: 'ä¸­è–ª', desc: `æ¯æ—¥ **9 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`,
            effect: (p) => { p.stableJob = { name: 'è£œç¿’ç­è€å¸«', pay: pay, hours: 9, desc: '9hr/æ—¥' }; return 'ç²å¾—ä¸­ç­‰å·¥ä½œ (9hr/æ—¥)'; }
        };
    },
    jobPartTime: () => {
        const turnsLeft = CONFIG.maxTurns - gameState.turn;
        const hours = randInt(2, 4);
        const basePay = hours * randInt(20, 30);
        const pay = getDynamicPay(basePay);
        const turns = randInt(3, Math.min(5, turnsLeft));
        if (turns <= 0) return generators.rest({sicknessCost: 0});
        return {
            title: 'ğŸ›µ å¤–é€å…¼è·', tag: 'å…¼è·', desc: `æ¯æ—¥é¡å¤–å·¥ä½œ ${hours} å°æ™‚ï¼Œæ¯è¼ª +$${pay}ï¼ŒæŒçºŒ ${turns} è¼ªã€‚`,
            effect: (p) => { p.partTimeJobs.push({ name: 'å¤–é€', pay: pay, hours: hours, turnsLeft: turns }); return `é–‹å§‹å…¼è· (æ¯æ—¥+${hours}hr, æŒçºŒ${turns}è¼ª)`; }
        };
    },
    bonusCash: () => {
        const bonus = randInt(80, 150);
        return {
            title: 'ğŸ‰ è€é—†è³ç´…åŒ…', tag: 'é¡å¤–æ”¶å…¥', desc: `è€é—†å¿ƒæƒ…å¥½ï¼é¡å¤–ç²å¾— $${bonus} ç¾é‡‘ã€‚`,
            effect: (p) => { p.cash += bonus; return `ç²å¾—çé‡‘ $${bonus}`; }
        };
    },
    bonusAnnual: () => {
        const bonus = randInt(200, 350);
        return {
            title: 'ğŸ å¹´åº¦åˆ†ç´…', tag: 'ç‰¹æ®Šæ”¶å…¥', desc: `å…¬å¸å¹´åº¦ç›ˆé¤˜å¤§å¢ï¼Œç²å¾— $${bonus} çé‡‘ã€‚`,
            effect: (p) => { p.cash += bonus; return `ç²å¾—å¹´åº¦åˆ†ç´… $${bonus}`; }
        };
    },
    depositFlexible: () => ({
        title: 'ğŸ’° å½ˆæ€§å­˜æ¬¾', tag: 'æ´»æœŸå­˜æ¬¾', desc: `é¸æ“‡å­˜å…¥ç¾é‡‘çš„ **20%, 50% æˆ– ALL**ã€‚ (é»æ“Šå¾Œè¼¸å…¥)`,
        effect: (p, amt) => {
            let amtToDeposit = Math.min(p.cash, amt);
            if (amtToDeposit <= 0) return 'æ²’ç¾é‡‘å¯å­˜';
            p.cash -= amtToDeposit;
            p.bank += amtToDeposit;
            return `å­˜å…¥ $${amtToDeposit}`;
        }
    }),
    depositFixed: () => {
        const turnsLeft = CONFIG.maxTurns - gameState.turn;
        const cost = randInt(100, 300);
        const turns = randInt(4, Math.min(8, turnsLeft));
        if (turns <= 0) return generators.depositFlexible();
        const fixedRate = randInt(5, 10) / 1000;
        const totalReturnRate = 1 + fixedRate * turns;
        return {
            title: 'ğŸ”’ å®šæœŸå­˜æ¬¾', tag: 'ç©©å®šç†è²¡', cost: cost,
            desc: `é–å®šç¾é‡‘ $${cost}ï¼Œ${turns} è¼ªå¾Œé ˜å›ã€‚ç¸½å ±é…¬ç‡ç´„ ${(fixedRate * turns * 100).toFixed(1)}%ã€‚`,
            effect: (p) => {
                const result = applyPayment(p, cost);
                if (result.includes('æˆåŠŸæ”¯ä»˜')) {
                    p.lockedSavings.push({ cost: cost, turnsLeft: turns, totalReturnRate: totalReturnRate, name: 'å®šå­˜' });
                    return `é–å®š $${cost}ï¼Œ${turns} è¼ªå¾Œé ˜å›ã€‚` + ` (${result})`;
                }
                return result; 
            }
        };
    },
    rateBoostLong: () => {
        const v = randInt(15, 40) / 1000;
        const turns = 3;
        return {
            title: 'ğŸ¦ éŠ€è¡ŒåŠ æ¯æ´»å‹•', tag: 'ç‰¹æ®Š', desc: `å­˜æ¬¾åˆ©ç‡åœ¨æ¥ä¸‹ä¾† ${turns} è¼ªè‡¨æ™‚ +${(v * 100).toFixed(1)}%ã€‚`,
            effect: (p) => { p.tempRateBoost.amount = v; p.tempRateBoost.turnsLeft = turns; return `åˆ©ç‡è‡¨æ™‚ +${(v * 100).toFixed(1)}% (${turns} è¼ª)`; }
        };
    },
    financialSeminar: () => {
        const v = randInt(10, 25) / 1000;
        const turns = 5;
        const cost = 20;
        return {
            title: 'ğŸ¤“ ç†è²¡è¬›åº§', tag: 'ä»˜è²»ç‰¹æ®Š', cost: cost,
            desc: `èŠ±è²» $${cost}ï¼Œå­˜æ¬¾åˆ©ç‡åœ¨æ¥ä¸‹ä¾† ${turns} è¼ªè‡¨æ™‚ +${(v * 100).toFixed(1)}%ã€‚`,
            effect: (p) => { 
                const result = applyPayment(p, cost);
                if (result.includes('æˆåŠŸæ”¯ä»˜')) {
                    p.tempRateBoost.amount = v; 
                    p.tempRateBoost.turnsLeft = turns; 
                    return `åƒåŠ è¬›åº§ï¼Œåˆ©ç‡è‡¨æ™‚ +${(v * 100).toFixed(1)}% (${turns} è¼ª)` + ` (${result})`;
                }
                return result; 
            }
        };
    },
    invest: () => {
        const turnsLeft = CONFIG.maxTurns - gameState.turn;
        const risk = randInt(10, 100);
        let riskTag = 'risk-low';
        let riskText = 'ä¸­ä½é¢¨éšª';
        if (risk > 50) { riskTag = 'risk-mid'; riskText = 'ä¸­é«˜é¢¨éšª'; }
        if (risk > 80) { riskTag = 'risk-high'; riskText = 'é«˜é¢¨éšª'; }
        const cost = randInt(50, 100);
        const maxRoi = 120 + Math.floor(risk * 1.5);
        const wait = randInt(2, Math.min(4, turnsLeft));
        if (wait <= 0) return generators.rest({sicknessCost: 0});
        return {
            title: 'ğŸš€ çŸ­æœŸæŠ•è³‡æ©Ÿæœƒ', tag: riskText, riskLevel: riskTag, cost: cost,
            desc: `æŠ•å…¥ $${cost}ï¼Œ${wait} è¼ªå¾Œçµç®—ã€‚é¢¨éšªå€¼: ${risk}ã€‚`,
            effect: (p) => {
                const result = applyPayment(p, cost);
                if (result.includes('æˆåŠŸæ”¯ä»˜')) {
                    p.investments.push({ cost: cost, maxRoi: maxRoi, risk: risk, turnsLeft: wait });
                    return `æŠ•å…¥è³‡é‡‘ $${cost}` + ` (${result})`;
                }
                return result; 
            }
            // ç”±æ–¼æŠ•è³‡æ˜¯æ­£å¸¸ä»˜è²»ï¼Œå› æ­¤ä¸éœ€è¦åœ¨ effect ä¸­è™•ç† applyLoss
        };
    },
    investStock: () => {
        // --- èª¿æ•´é‚è¼¯ï¼šå‰æœŸ (T1~T4) é™ä½æˆæœ¬ ---
        let cost;
        if (gameState.turn <= 4) {
            cost = randInt(100, 250); // å‰æœŸä½æˆæœ¬
        } else {
            cost = randInt(300, 500); // å¾ŒæœŸæ¢å¾©åŸæˆæœ¬
        }
        
        const turnsLeft = CONFIG.maxTurns - gameState.turn;
        const avgDiv = 12;
        const estimatedProfit = turnsLeft > 0 ? turnsLeft * avgDiv * Math.floor(cost / 100) : 0;
        const estimatedROI = cost > 0 ? ((estimatedProfit / cost) * 100).toFixed(1) : 0;
        return {
            title: 'ğŸ¦ è—ç±Œè‚¡æŠ•è³‡', tag: 'é•·æœŸç©©å®š', cost: cost,
            desc: `æŠ•å…¥ $${cost} è²·å…¥è—ç±Œè‚¡ï¼Œæ¯è¼ªæ”¶å–è‚¡åˆ©ã€‚ä¼°è¨ˆç¸½å ±é…¬ç‡ç´„ ${estimatedROI}%ã€‚`,
            effect: (p) => {
                const result = applyPayment(p, cost);
                if (result.includes('æˆåŠŸæ”¯ä»˜')) {
                    let existingStock = p.stocks.find(s => s.name === 'è—ç±Œè‚¡');
                    if (existingStock) {
                        existingStock.cost += cost;
                        return `å†æ¬¡æŠ•å…¥ $${cost} è³¼è²·è—ç±Œè‚¡` + ` (${result})`;
                    } else {
                        p.stocks.push({ name: 'è—ç±Œè‚¡', cost: cost });
                        return `æŠ•å…¥ $${cost} è³¼è²·è—ç±Œè‚¡` + ` (${result})`;
                    }
                }
                return result; 
            }
        };
    },
    rest: (p) => {
        const baseCost = 20;
        const totalCost = baseCost + p.sicknessCost; 
        const healAmt = 15;
        const desc = p.sicknessCost > 0 
            ? `èŠ±è²» $${baseCost} + é†«ç™‚è²» $${p.sicknessCost} = $${totalCost} é€²è¡Œæ²»ç™‚ï¼Œæ¢å¾© ${healAmt} é»å¥åº·ã€‚`
            : `èŠ±è²» $${baseCost} é€²è¡Œèª¿é¤Šï¼Œæ¢å¾© ${healAmt} é»å¥åº·å€¼ã€‚`;

        return {
            title: 'ğŸ§˜ æ·±åº¦ä¼‘æ¯', tag: 'å¥åº·/æ²»ç™‚', cost: totalCost, 
            desc: desc,
            effect: (p) => {
                const result = applyPayment(p, totalCost);
                if (!result.includes('æˆåŠŸæ”¯ä»˜')) {
                    return 'è³‡ç”¢ä¸è¶³ï¼Œç„¡æ³•æ”¯ä»˜ï¼'; 
                }

                p.hp = Math.min(CONFIG.maxHp, p.hp + healAmt);
                let report = `å¥åº·æ¢å¾© +${healAmt}`;
                
                if (p.sicknessCost > 0) {
                    report += `ï¼Œæ¸…é™¤é†«ç™‚è²»ç”¨ $${p.sicknessCost}ã€‚`;
                    p.sicknessCost = 0; 
                }
                return report + ` (${result})`;
            }
        };
    },
    
    // --- è©é¨™/é«˜é¢¨éšªå¡ç‰‡ç”Ÿæˆå™¨ (ä¿®æ­£æ—¥èªŒå’Œæƒ…å¢ƒ) ---
    scamCrypto: () => {
        const scenarios = [
            'ã€Œéš”å£ç‹å§ã€æ¨è–¦ä½ åŠ å…¥ LINE ç¾¤çµ„ï¼Œè™Ÿç¨±æŠ•è³‡è™›æ“¬è²¨å¹£ä¸€é€±ç¿»å€ï¼Œèª˜æƒ‘ä½ æŠ•å…¥**å¤§é‡è³‡é‡‘**ã€‚',
            'çœ‹åˆ°ç¶²ç´…åœ¨é™æ™‚å‹•æ…‹é¼“å¹è²·å…¥ã€Œç‹—å¹£ã€ï¼Œè²ç¨±éŒ¯éé€™æ¬¡æœƒå¾Œæ‚”ä¸€è¼©å­ã€‚',
            'æ”¶åˆ°ä¸€å°è‹±æ–‡éƒµä»¶ï¼Œé‚€è«‹ä½ åƒåŠ ã€Œæœªä¾†é‡‘èç§‘æŠ€ã€çš„ç§å¯†ä»£å¹£èªè³¼ã€‚',
            'æœ‹å‹ä»‹ç´¹ä½ ä¸€å€‹ç¥ç§˜çš„å€å¡Šéˆé …ç›®ï¼Œæ‰¿è«¾æä¾› 100% ä¿è­‰å›å ±ã€‚'
        ];
        return {
            title: 'ğŸ’¥ é£†å‡å¹£æŠ•è³‡', tag: 'è©é¨™é™·é˜±', 
            cost: 0, 
            scamCost: true, 
            desc: scenarios[randInt(0, scenarios.length - 1)] + ' (æå¤±å¤§é‡è³‡é‡‘)',
            effect: (p) => { 
                const loss = randInt(CONFIG.scamLossRange[0], CONFIG.scamLossRange[1]);
                const cashBefore = p.cash;
                const bankBefore = p.bank;
                const actualLoss = applyLoss(p, loss);
                p.hp = Math.max(0, p.hp - 5);
                
                // æª¢æŸ¥æ˜¯å¦ç”¢ç”Ÿå‚µå‹™
                let logMsg = `ğŸ’£ å‡æŠ•è³‡å¹³å°ï¼ŒæŠ•å…¥çš„è³‡é‡‘ $${actualLoss} æ­¸é›¶ã€‚å¥åº· -5ã€‚`;
                if (p.bank < 0 && p.bank < bankBefore) { 
                    logMsg += ` (âš ï¸ æ´»å­˜è®Šè² å‚µ $${Math.abs(p.bank)})`;
                }
                return logMsg;
            }
        };
    },
    scamSocial: () => {
        const scenarios = [
            'æœ‰äººé€é FB ç§è¨Šä½ é«˜è–ªåœ‹å¤–æ©Ÿæœƒï¼Œè²ç¨±åªéœ€è¦æ”¯ä»˜æ‰‹çºŒè²»å’Œæ©Ÿç¥¨ã€‚',
            'æ”¶åˆ°ä¾†è‡ªé™Œç”Ÿäººçš„é«˜é »è¨Šæ¯ï¼Œç¨±å…¶ç‚ºã€Œæƒ…æ„Ÿå°å¸«ã€ä¸¦è¦æ±‚åŒ¯æ¬¾ä»¥è§£é™¤å„é‹ã€‚',
            'åœ¨äº¤å‹è»Ÿé«”ä¸Šé‡åˆ°ä¸€å€‹å®Œç¾å°è±¡ï¼Œå°æ–¹è¡¨ç¤ºéœ€è¦è³‡é‡‘é€²è¡Œç·Šæ€¥æŠ•è³‡ã€‚'
        ];
        return {
            title: 'âŒ åœ‹å¤–é«˜è–ªæ©Ÿæœƒ', tag: 'è©é¨™é™·é˜±', 
            cost: 0, 
            scamCost: true, 
            desc: scenarios[randInt(0, scenarios.length - 1)] + ' (æå¤±ä¸€ç­†è³‡é‡‘)',
            effect: (p) => { 
                const loss = randInt(CONFIG.scamLossRange[0], CONFIG.scamLossRange[1]);
                const cashBefore = p.cash;
                const bankBefore = p.bank;
                const actualLoss = applyLoss(p, loss);
                p.hp = Math.max(0, p.hp - 10);
                
                let logMsg = `ğŸ’¥ è¢«è©é¨™ï¼æå¤± $${actualLoss}ï¼Œå¥åº· -10 (å‡ºåœ‹å·®é»è¢«é—œåœ¨è©é¨™åœ’å€)ã€‚`;
                if (p.bank < 0 && p.bank < bankBefore) { 
                    logMsg += ` (âš ï¸ æ´»å­˜è®Šè² å‚µ $${Math.abs(p.bank)})`;
                }
                return logMsg;
            }
        };
    },
    scamInsurance: () => {
        const scenarios = [
            'è¦ªæˆšæ¨éŠ·é«˜å ±é…¬ä¿å–®ï¼Œå¼·èª¿å„²è“„åŠŸèƒ½ï¼Œä½†ä¿è²»ç•°å¸¸æ˜‚è²´ã€‚',
            'ä¿éšªæ¥­å‹™å“¡è¡¨ç¤ºé€™æ¬¾ç”¢å“æœ‰ã€Œä¿è­‰å›æœ¬ã€æ‰¿è«¾ï¼Œå¼·çƒˆå»ºè­°ä½ ä¸€æ¬¡ç¹³æ¸…å¤§é¡ä¿è²»ã€‚',
            'æ¥åˆ°é›»è©±æ¨éŠ·ï¼Œè²ç¨±èƒ½å¹«ä½ è¦åŠƒä¸€å€‹ã€Œç¯€ç¨…ã€å°ˆæ¡ˆï¼Œéœ€ç«‹å³å¤§ç­†æŠ•å…¥ã€‚'
        ];
        return {
            title: 'ğŸ’¸ é«˜å ±é…¬ä¿å–®', tag: 'å¼·è¿«æ¨éŠ·', 
            cost: 0, 
            scamCost: true, 
            desc: scenarios[randInt(0, scenarios.length - 1)] + ' (å¤§é¡æ”¯å‡º)',
            effect: (p) => { 
                const loss = randInt(CONFIG.scamLossRange[0], CONFIG.scamLossRange[1]);
                const cashBefore = p.cash;
                const bankBefore = p.bank;
                const actualLoss = applyLoss(p, loss);

                let logMsg = `ğŸ’¸ è¢«å¼·è¿«æ¨éŠ·ï¼æå¤± $${actualLoss} è²·äº†ä¸€æ•´å¥—è¶…è²´ä¿å–®ã€‚`;
                if (p.bank < 0 && p.bank < bankBefore) { 
                    logMsg += ` (âš ï¸ æ´»å­˜è®Šè² å‚µ $${Math.abs(p.bank)})`;
                }
                return logMsg;
            }
        };
    },
};


function generateCards(playerIdx) {
    let pool = [];
    const player = gameState.players[playerIdx];

    // T1 ç‰¹æ®Šè™•ç† (é¸å·¥ä½œ)
    if (gameState.turn === 1) {
        const t1Jobs = [
            generators.jobStableStandard, generators.jobStableShift,
            generators.jobStableOvertime, generators.jobStableLow, generators.jobStableMed
        ];
        
        let uniqueT1Deck = [];
        for (let i = t1Jobs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [t1Jobs[i], t1Jobs[j]] = [t1Jobs[j], t1Jobs[i]];
        }
        uniqueT1Deck = t1Jobs.map(genFunc => genFunc());
        gameState.currentCards = uniqueT1Deck;
        
    } else {
        
        let jobPool = [
            generators.jobStableStandard, generators.jobStableShift,
            ...(gameState.turn <= CONFIG.maxTurns - 5 ? [generators.jobStableOvertime] : []) 
        ];

        // æ­£å¸¸å¡æ± 
        pool = [
            ...jobPool,
            generators.jobPartTime, generators.jobPartTime,
            generators.bonusCash, generators.bonusAnnual, generators.financialSeminar,
            generators.depositFlexible, generators.rateBoostLong, generators.depositFixed,
            generators.invest, generators.invest, generators.invest,
            generators.investStock,
            // --- è©é¨™å¡ç‰‡ï¼šå°‡å…¶åŠ å…¥å…©æ¬¡ï¼Œä»¥é™ä½ç›¸å°å‡ºç¾æ©Ÿç‡ ---
            generators.depositFlexible, generators.bonusCash, generators.financialSeminar,
            generators.rateBoostLong, generators.depositFixed, generators.invest, 
            generators.scamCrypto, generators.scamSocial, generators.scamInsurance, 
        ]; 

        let uniqueDeck = [];
        let cardTitles = new Set();
        const maxAttempts = pool.length * 3; 
        let attempts = 0;

        while(uniqueDeck.length < 5 && attempts < maxAttempts) {
            let genFunc = pool[Math.floor(Math.random() * pool.length)];
            let card = genFunc();
            
            if (card.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯') card = generators.rest(player);

            if (card && !cardTitles.has(card.title)) {
                cardTitles.add(card.title);
                uniqueDeck.push(card);
            }
            attempts++;
        }
        gameState.currentCards = uniqueDeck;
    }
    
    // æª¢æŸ¥æ˜¯å¦éœ€è¦å¼·åˆ¶æ²»ç™‚
    if (player.hp <= CONFIG.lowHpThreshold) {
        let restCard = generators.rest(player);
        
        if (!gameState.currentCards.some(c => c.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯')) {
             gameState.currentCards[0] = restCard;
             gameState.currentCards = gameState.currentCards.slice(0, 5);
        } else {
            const restIndex = gameState.currentCards.findIndex(c => c.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯');
            gameState.currentCards[restIndex] = restCard;
        }
    }
    
    renderCards(false);
}

function renderCards(isSpecialEvent) {
    const container = document.getElementById('cards-container');
    container.innerHTML = '';
    
    const playerIdx = gameState.phase.startsWith('p1') ? 0 : 1;
    const player = gameState.players[playerIdx];
    const totalLiquidAssets = player.cash + player.bank;
    const isForceHealing = player.hp <= CONFIG.lowHpThreshold && !isSpecialEvent; 

    // æ­£å¸¸å›åˆæ¸²æŸ“
    container.style.justifyContent = 'space-between';
    container.style.flexWrap = 'wrap';
    container.style.maxWidth = 'none'; 


    gameState.currentCards.forEach((card, idx) => {
        let div = document.createElement('div');
        let isScam = card.scamCost !== undefined; // åˆ¤æ–·æ˜¯å¦ç‚ºè©é¨™å¡

        div.className = `card ${isScam ? 'scam' : ''}`; 
        div.id = `card-${idx}`; 
        
        let tagClass = 'tag-none';
        let clickText = 'é»æ“Šé¸æ“‡';
        let isDisabled = false;
        let disableReason = '';
        const cost = getCardCost(card); // æ­£å¸¸å¡ç‰‡æˆæœ¬ (è©é¨™å¡ cost=0)

        // æ¨™ç±¤å’Œç¦ç”¨é‚è¼¯
        if (isScam) {
            tagClass = 'tag-scam';
            clickText = `é¸æ“‡ (é«˜é¢¨éšªï¼Œä¸€æ—¦é¸æ“‡å¼·åˆ¶åŸ·è¡Œ)`;
            // è©é¨™å¡å…è¨±é¸æ“‡ï¼Œä¸æª¢æŸ¥è³‡ç”¢
        } else {
            if (card.tag.includes('é¢¨éšª')) tagClass = `tag-${card.riskLevel}`;
            else if (card.tag.includes('å·¥ä½œ') || card.tag.includes('å…¼è·')) tagClass = 'tag-job';
            else if (card.tag.includes('ç‰¹æ®Š')) tagClass = 'tag-special';
            else tagClass = 'tag-risk-low'; // å…¶ä»–ä¸€èˆ¬ç†è²¡å¡

            clickText = (card.title === 'ğŸ’° å½ˆæ€§å­˜æ¬¾') ? 'é»æ“Šè¼¸å…¥æ¯”ä¾‹ (ç«‹å³åŸ·è¡Œ)' : 'é»æ“Šé¸æ“‡';

            // ä¿®æ­£é»ï¼šæª¢æŸ¥ç¾é‡‘ + å­˜æ¬¾ç¸½é¡æ˜¯å¦è¶³å¤ 
            if (cost > totalLiquidAssets && cost > 0) {
                 isDisabled = true;
                 disableReason = `ğŸš¨ è³‡ç”¢($${totalLiquidAssets})ä¸è¶³$${cost}ï¼Œç„¡æ³•é¸æ“‡æ­¤é …ã€‚`;
            }

            if (isForceHealing) {
                if (card.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯' && !isDisabled) {
                    div.classList.add('force-heal');
                    clickText = `ğŸš¨ å¿…é ˆæ²»ç™‚ $${card.cost}`;
                } else {
                    isDisabled = true;
                    disableReason = `ğŸš¨ å¿…é ˆå…ˆæ²»ç™‚ (HP<${CONFIG.lowHpThreshold})`;
                }
            }
        }
        
        // æª¢æŸ¥æ˜¯å¦å·²è¢«é¸ä¸­ (ç”¨æ–¼æ­£å¸¸å¡) æˆ–å·²è¢«åŸ·è¡Œ (ç”¨æ–¼è©é¨™/å­˜æ¬¾å¡)
        let isSelectedOrExecuted = gameState.selectedIndices.includes(idx) || 
                                   (document.getElementById(`card-${idx}`) && document.getElementById(`card-${idx}`).classList.contains('disabled'));

        if (isDisabled || isSelectedOrExecuted) {
            div.classList.add('disabled');
            if (!isDisabled) disableReason = 'âœ… å·²åŸ·è¡Œ/å·²é¸æ“‡';
            clickText = disableReason || clickText;
        }

        if (gameState.selectedIndices.includes(idx)) {
            div.classList.add('selected');
        }


        div.innerHTML = `
            <div>
                <div class="card-header">
                    <div class="card-title">${card.title}</div>
                    <span class="tag ${tagClass}">${card.tag}</span>
                </div>
                <div class="card-desc">${card.desc}</div>
            </div>
            <small style="color:#7f8c8d; font-size:0.9em;">${clickText}</small>
        `;
        
        // **ä¿®æ­£:** é‡æ–°è³¦äºˆ onclickï¼Œä¸¦æª¢æŸ¥æ˜¯å¦å·²ç¦ç”¨
        if (!isDisabled) {
            div.onclick = () => {
                handleCardClick(idx);
            };
        } else {
            div.onclick = null;
        }

        container.appendChild(div);
    });
    
    // å¦‚æœå¼·åˆ¶æ²»ç™‚å¡ç‰‡å¯ç”¨ï¼Œè®“ç¢ºèªæŒ‰éˆ•å¯ç”¨
    if (isForceHealing && gameState.currentCards.some(c => c.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯' && !document.getElementById(`card-${gameState.currentCards.findIndex(c => c.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯')}`).classList.contains('disabled'))) {
        document.getElementById('confirm-btn').disabled = false;
        document.getElementById('confirm-btn').innerText = `ç¢ºèªè¡Œå‹• (å¼·åˆ¶æ²»ç™‚)`;
    }
}


// --- çµç®—æ ¸å¿ƒ ---
function processTurn() {
    log(`--- ç¬¬ ${gameState.turn} è¼ªçµç®— ---`, 'turn');
    
    handleGlobalEvents(); // åœ¨çµç®—é–‹å§‹æ™‚è™•ç†éš¨æ©Ÿäº‹ä»¶

    gameState.players.forEach(p => {
        let logs = [];
        p.roundIncome = 0;
        let jobIncome = 0; 
        
        // --- 1. è¨ˆç®—å·¥æ™‚èˆ‡å¥åº· ---
        let dailyHours = 0;
        if (p.stableJob) dailyHours += p.stableJob.hours;
        p.partTimeJobs.forEach(j => dailyHours += j.hours);
        
        if (dailyHours > CONFIG.safeHours) {
            let over = dailyHours - CONFIG.safeHours;
            let dmg = over * CONFIG.overworkPenalty;
            p.hp -= dmg;
            logs.push(`<span class="log-bad">éå‹(${dailyHours}hr) å¥åº· -${dmg.toFixed(1)}</span>`);
        }
        
        // --- 2. ç–¾ç—…åˆ¤å®š ---
        if (p.hp < CONFIG.maxHp && p.sicknessCost === 0) {
            let sickChance = (100 - p.hp) * 0.7 / 100;
            if (Math.random() < sickChance) {
                p.sicknessCost = CONFIG.minSickCost;
                logs.push(`<span class="log-bad">ğŸ¤’ å…ç–«åŠ›ä½ä¸‹ï¼Œç´¯ç©é†«ç™‚è²»ç”¨ $${p.sicknessCost}</span>`);
            }
        } else if (p.sicknessCost > 0) {
            let addedCost = randInt(10, 50);
            p.sicknessCost += addedCost;
            logs.push(`<span class="log-bad">ğŸš¨ ç–¾ç—…æƒ¡åŒ–ï¼Œé†«ç™‚è²»ç”¨å†ç´¯è¨ˆ +$${addedCost} (ç¸½è¨ˆ$${p.sicknessCost})</span>`);
            p.hp -= 3;
        }


        // --- 3. æ”¶å…¥çµç®— ---
        if (p.stableJob) {
            p.roundIncome += p.stableJob.pay;
            p.cash += p.stableJob.pay;
            jobIncome += p.stableJob.pay;
        }
        
        p.partTimeJobs.forEach(j => {
            p.roundIncome += j.pay;
            p.cash += j.pay;
            jobIncome += j.pay;
            j.turnsLeft--;
        });
        p.partTimeJobs = p.partTimeJobs.filter(j => j.turnsLeft > 0);
        
        if (jobIncome > 0) {
             logs.push(`<span class="log-good">å·¥ä½œæ”¶å…¥ +$${jobIncome}</span>`);
        }
        
        // --- 4. è‚¡ç¥¨è‚¡åˆ©æ”¶å…¥ ---
        let dividendIncome = 0;
        p.stocks.forEach(s => {
            let baseDiv = Math.floor(s.cost / 100);
            let dividend = randInt(8, 15) * baseDiv; 
            p.cash += dividend;
            p.roundIncome += dividend;
            dividendIncome += dividend;
        });
        if (dividendIncome > 0) {
             logs.push(`<span class="log-good">ğŸ’¸ è‚¡åˆ©æ”¶å…¥ +$${dividendIncome}</span>`);
        }

        // --- 5. æŠ•è³‡çµç®— (çŸ­æœŸé¢¨éšª) ---
        p.investments = p.investments.filter(inv => {
            inv.turnsLeft--;
            if (inv.turnsLeft === 0) {
                let roll = Math.random() * 100; 
                
                if (roll < (inv.risk / 2.5)) {
                    let lossRate = randInt(10, 50 + inv.risk/2); 
                    if (inv.risk > 80 && Math.random() < 0.2) lossRate = 150; 
                    
                    let returnVal = Math.floor(inv.cost * (100 - lossRate) / 100);
                    let netLoss = inv.cost - returnVal; 
                    p.cash += returnVal; 
                    logs.push(`<span class="log-bad">æŠ•è³‡å¤±åˆ©(R:${inv.risk}) è™§æ $${netLoss}</span>`);
                } else {
                    let profitRate = randInt(10, inv.maxRoi - 100);
                    let totalBack = Math.floor(inv.cost * (100 + profitRate) / 100);
                    let netProfit = totalBack - inv.cost;
                    p.cash += totalBack;
                    logs.push(`<span class="log-good">æŠ•è³‡ç²åˆ©(R:${inv.risk}) +$${netProfit}</span>`);
                    p.roundIncome += netProfit;
                }
                return false; 
            }
            return true; 
        });
        
        // --- 6. å®šå­˜çµç®— ---
        p.lockedSavings = p.lockedSavings.filter(locked => {
            locked.turnsLeft--;
            if (locked.turnsLeft === 0) {
                let returnAmt = Math.floor(locked.cost * locked.totalReturnRate);
                let netProfit = returnAmt - locked.cost;
                p.cash += returnAmt;
                logs.push(`<span class="log-good">å®šå­˜åˆ°æœŸ +$${returnAmt} (æ·¨åˆ©+$${netProfit})</span>`);
                p.roundIncome += netProfit; 
                return false; 
            }
            return true; 
        });


        // --- 7. å¼·åˆ¶æ”¯å‡º (ç”Ÿæ´»è²» + åä¸€) ---
        let totalObligation = CONFIG.livingCost;
        if (p.roundIncome > 0) {
            totalObligation += Math.floor(p.roundIncome * CONFIG.titheRate);
        }
        
        let actualPayment = totalObligation; // ç¸½æ¬ æ¬¾é¡åº¦

        // **ä¿®æ­£é»ï¼šä½¿ç”¨ applyLoss ç¢ºä¿å…ˆæ‰£ç¾é‡‘å†æ‰£å­˜æ¬¾**
        applyLoss(p, actualPayment);


        logs.push(`ç”Ÿæ´»è²» + å¥‰ç» -$${totalObligation}`);
        
        // --- 8. åˆ©æ¯ (æ´»å­˜) ---
        let currentRate = CONFIG.baseRate; 
        
        if (p.tempRateBoost.turnsLeft > 0) {
            currentRate = CONFIG.baseRate + p.tempRateBoost.amount;
            p.tempRateBoost.turnsLeft--; 
        } else {
            p.tempRateBoost.amount = 0; 
        }
        
        // åªæœ‰å­˜æ¬¾ç‚ºæ­£æ™‚æ‰è¨ˆç®—åˆ©æ¯
        if (p.bank > 0) {
            let interest = Math.floor(p.bank * currentRate);
            if (interest > 0) {
                p.bank += interest;
                logs.push(`æ´»å­˜åˆ©æ¯(${(currentRate*100).toFixed(1)}%) <span class="log-good">+$${interest}</span>`);
                p.roundIncome += interest;
            }
        }
        
        // --- 9. ç ´ç”¢/è² å‚µè™•ç† (ç¢ºä¿ cash/bank UI é¡¯ç¤ºæ­£ç¢º) ---
        if (p.hp < 0) p.hp = 0;
        if (p.hp > CONFIG.maxHp) p.hp = CONFIG.maxHp;

        if (logs.length) log(`${p.name}: ${logs.join(' | ')}`);
    });
    
    gameState.turn++;
    if (gameState.turn > CONFIG.maxTurns) {
        endGame();
    } else {
        startPlayerTurn(0);
    }
}

/**
 * éš¨æ©Ÿçµç®—äº‹ä»¶ (å¼·åŒ–ç‰ˆæœ¬)
 */
function handleGlobalEvents() {
    // å¾ç¬¬ 2 è¼ªé–‹å§‹ï¼Œ40% æ©Ÿç‡è§¸ç™¼
    if (gameState.turn > 1 && Math.random() < 0.4) { 
        const events = [
            // è² é¢äº‹ä»¶ (amt > 0 ç‚ºæå¤±)
            { t: 'ğŸ’¸ æ”¶åˆ°ç‡ƒæ–™ç¨…å–®', amt: 30, type: 'bad' },
            { t: 'âš¡ å¤å­£é›»è²»å¸³å–®', amt: 25, type: 'bad' },
            { t: 'ğŸš— æ©Ÿè»Šå¼·åˆ¶éšªçºŒä¿', amt: 15, type: 'bad' },
            { t: 'ğŸ“± æ‰‹æ©Ÿè¢å¹•æ‘”å£', amt: 40, type: 'bad' },
            { t: 'ğŸš¨ äº¤é€šç½°å–®', amt: 50, type: 'bad' },
            // æ­£é¢äº‹ä»¶ (amt < 0 ç‚ºæ”¶å…¥)
            { t: 'ğŸ æ”¶åˆ°è¦ªå‹ç¦®é‡‘', amt: -50, type: 'good' }, 
            { t: 'ğŸ€ æ„å¤–ç²å¾—æŠ½çé‡‘', amt: -80, type: 'good' },
            { t: 'ğŸ’° æ’¿åˆ°é›¶éŒ¢', amt: -20, type: 'good' }
        ];
        let event = events[randInt(0, events.length-1)];
        
        const logType = event.type === 'good' ? 'good' : 'scam'; 
        const amount = Math.abs(event.amt);
        
        log(`[éš¨æ©Ÿäº‹ä»¶] ${event.t} ${event.amt > 0 ? 'å¼·åˆ¶æ‰£æ¬¾' : 'ç²å¾—æ”¶å…¥'} ${event.amt > 0 ? '-' : '+'}$${amount}`, logType);
        
        gameState.players.forEach(p => {
            let cost = event.amt; 
            
            if (cost > 0) { // å¸³å–®/æå¤±
                 // **ä¿®æ­£é»ï¼šä½¿ç”¨ applyLoss ç¢ºä¿å…ˆæ‰£ç¾é‡‘å†æ‰£å­˜æ¬¾**
                applyLoss(p, cost);
            } else { // æ”¶å…¥/å¢ç›Š
                p.cash += amount; 
            }
        });
    }
}

// --- è¼”åŠ©å‡½å¼ ---
function updateUI() {
    document.getElementById('turn-display').innerText = `ç¬¬ ${gameState.turn} / ${CONFIG.maxTurns} è¼ª`;
    
    let phaseText = '';
    const playerPrefix = gameState.phase.startsWith('p1') ? 'A' : 'B';
    
    if (gameState.phase.endsWith('_choice')) {
         phaseText = `${playerPrefix} çµ„è¡Œå‹• (é¸ 1-${gameState.maxSelections} å¼µ)`;
    } else {
         phaseText = 'çµç®—ä¸­...';
    }

    document.getElementById('phase-msg').innerText = phaseText;

    updatePlayerUI(0, 'p1');
    updatePlayerUI(1, 'p2');

    document.getElementById('p1-stats').classList.toggle('active', gameState.phase.startsWith('p1'));
    document.getElementById('p2-stats').classList.toggle('active', gameState.phase.startsWith('p2'));
}

function updatePlayerUI(idx, prefix) {
    let p = gameState.players[idx];
    
    // ç¸½è³‡ç”¢è¨ˆç®—åŒ…æ‹¬è² çš„ç¾é‡‘/å­˜æ¬¾
    document.getElementById(`${prefix}-total-asset`).innerText = `$${getAssets(p, true)}`;
    document.getElementById(`${prefix}-investment-asset`).innerText = `$${getAssets(p, false, true)}`;


    let cashEl = document.getElementById(`${prefix}-cash`);
    cashEl.innerText = `$${p.cash}`;
    cashEl.className = p.cash < 0 ? 'money debt' : 'money';
    
    let bankEl = document.getElementById(`${prefix}-bank`);
    bankEl.innerText = `$${p.bank}`;
    bankEl.className = p.bank < 0 ? 'money debt' : 'money'; // é¡¯ç¤ºè² å‚µ

    
    let hpText = Math.floor(p.hp);
    if (p.sicknessCost > 0) hpText += ` (ç—…å‚µ$${p.sicknessCost})`;
    
    document.getElementById(`${prefix}-hp-text`).innerText = hpText;
    let hpBar = document.getElementById(`${prefix}-hp-bar`);
    hpBar.style.width = `${Math.max(0, p.hp)}%`;
    if (p.hp < CONFIG.lowHpThreshold) hpBar.style.background = '#e74c3c';
    else if (p.hp < 70) hpBar.style.background = '#f39c12';
    else hpBar.style.background = '#27ae60';

    let finalRate = CONFIG.baseRate;
    let rateText = (CONFIG.baseRate * 100).toFixed(1) + '%';
    
    if (p.tempRateBoost.turnsLeft > 0) {
        finalRate = CONFIG.baseRate + p.tempRateBoost.amount;
        rateText = `${(finalRate * 100).toFixed(1)}% (+${p.tempRateBoost.turnsLeft} è¼ª)`;
    } 

    document.getElementById(`${prefix}-rate`).innerText = rateText;

    let statusParts = [];
    if (p.stableJob) {
        statusParts.push(`æ­£è·: ${p.stableJob.name} (${p.stableJob.hours}hr/æ—¥)`);
    }
    else statusParts.push("å¾…æ¥­ä¸­");
    
    if (p.partTimeJobs.length > 0) statusParts.push(`å…¼è·x${p.partTimeJobs.length} (${p.partTimeJobs.reduce((sum, j) => sum + j.hours, 0)}hr)`);
    if (p.investments.length > 0) statusParts.push(`çŸ­æœŸæŠ•è³‡x${p.investments.length}`);
    if (p.lockedSavings.length > 0) statusParts.push(`å®šå­˜x${p.lockedSavings.length}`); 
    if (p.stocks.length > 0) statusParts.push(`è‚¡ç¥¨x${p.stocks.length}`); 
    
    document.getElementById(`${prefix}-status`).innerText = statusParts.join(' | ');
}

function getAssets(p, includeCashAndBank = false, onlyInvestments = false) {
    let val = 0;
    
    p.investments.forEach(i => val += Math.floor(i.cost * 0.5)); 
    p.lockedSavings.forEach(i => val += i.cost); 
    p.stocks.forEach(i => val += i.cost); 

    if (onlyInvestments) {
        return val;
    }
    
    if (includeCashAndBank) {
        val += p.cash;
        val += p.bank;
    }

    return val;
}


function endGame() {
    stopTimer(); 
    
    const p1Total = getAssets(gameState.players[0], true);
    const p2Total = getAssets(gameState.players[1], true);
    
    let winner = p1Total > p2Total ? "ğŸ† A çµ„ç²å‹ï¼" : (p2Total > p1Total ? "ğŸ† B çµ„ç²å‹ï¼" : "ğŸ¤ å¹³æ‰‹ï¼");

    let finalReport = `
        <div style="margin-top: 20px; padding: 15px; background: #fdf6e3; border: 1px solid #f9e2af; border-radius: 5px;">
            <h3 style="color:#e67e22; border-bottom: 2px dashed #f9e2af; padding-bottom: 5px; margin-bottom: 10px;">ğŸ“Š éŠæˆ²æœ€çµ‚ç¸½çµå ±å‘Š</h3>
            ${gameState.players.map(p => {
                const totalAsset = getAssets(p, true);
                const investmentAsset = getAssets(p, false, true);
                return `
                    <div style="margin-bottom: 15px; border-left: 4px solid ${p.id === 0 ? '#3498db' : '#27ae60'}; padding-left: 10px;">
                        <strong style="font-size: 1.1em;">${p.name}</strong> 
                        (å¥åº·: ${Math.floor(p.hp)}${p.sicknessCost > 0 ? ` âš ï¸ç—…å‚µ$${p.sicknessCost}` : ''})
                        <ul>
                            <li>ç¸½è³‡ç”¢ (ä¼°): <span class="total-asset">$${totalAsset}</span></li>
                            <li>ç¾é‡‘/æ´»å­˜: <span class="${p.cash < 0 ? 'debt' : 'money'}">$${p.cash}</span> / <span class="${p.bank < 0 ? 'debt' : 'money'}">$${p.bank}</span></li>
                            <li>æŠ•è³‡è³‡ç”¢ç¸½é¡ (å®šå­˜/è‚¡ç¥¨/çŸ­æœŸæŠ•è³‡æœ¬é‡‘): <span class="money">$${investmentAsset}</span></li>
                            <li>ä¸»è¦å·¥ä½œ: ${p.stableJob ? p.stableJob.name : 'ç„¡'}</li>
                        </ul>
                    </div>
                `;
            }).join('')}
        </div>
    `;


    let html = `
        <div style="text-align:center; background:white; padding:30px; border-radius:10px;">
            <h1 style="color:#e67e22; font-size: 2.5em;">${winner}</h1>
            <div style="display:flex; justify-content:space-around; margin:30px 0;">
                <div style="font-size: 1.2em;">
                    <h3>A çµ„æœ€çµ‚è³‡ç”¢</h3>
                    <div style="font-size:2.5em; color:#27ae60">$${p1Total}</div>
                    <small>å¥åº·: ${Math.floor(gameState.players[0].hp)}</small>
                </div>
                <div style="font-size: 1.2em;">
                    <h3>B çµ„æœ€çµ‚è³‡ç”¢</h3>
                    <div style="font-size:2.5em; color:#27ae60">$${p2Total}</div>
                    <small>å¥åº·: ${Math.floor(gameState.players[1].hp)}</small>
                </div>
            </div>
            ${finalReport}
            <button class="confirm-btn" onclick="location.reload()">å†ä¾†ä¸€å±€</button>
        </div>
    `;
    document.getElementById('cards-container').innerHTML = html;
}

function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function log(msg, type='') {
    const area = document.getElementById('game-log');
    const div = document.createElement('div');
    div.className = 'log-entry';
    if (type === 'turn') div.innerHTML = `<span class="log-turn">${msg}</span>`;
    else if (type === 'bad') div.innerHTML = `<span class="log-bad">${msg}</span>`;
    else if (type === 'good') div.innerHTML = `<span class="log-good">${msg}</span>`;
    else if (type === 'scam') div.innerHTML = `<span class="log-scam">${msg}</span>`; // ä½¿ç”¨ scam log é¡è‰²
    else div.innerHTML = msg;
    area.prepend(div);
    // ç¢ºä¿æ—¥èªŒè¦–åœ–æ»¾å‹•åˆ°é ‚éƒ¨ä»¥é¡¯ç¤ºæœ€æ–°æ¶ˆæ¯
    area.scrollTop = 0;
}
</script>
</body>
</html>
