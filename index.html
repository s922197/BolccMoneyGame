<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤¾ç•œç”Ÿå­˜æˆ°ï¼šç†è²¡ Roguelike v6.3 (NaNèˆ‡å¥‰ç»ä¿®æ­£ç‰ˆ)</title>
    <style>
        /* --- CSS æ¨£å¼å€ --- */
        :root {
            --primary: #2c3e50;
            --accent: #27ae60;
            --danger: #e74c3c;
            --warning: #f39c12;
            --bg: #ecf0f1;
            --card-bg: #fff;
            font-size: 18px; 
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--primary);
            margin: 0;
            padding: 15px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }
        .container {
            max-width: 1400px;
            width: 100%;
        }
        
        #setup-screen h1 { font-size: 2.5em; }
        #setup-screen h3 { font-size: 1.5em; }
        #setup-screen p { font-size: 1.1em; }
        .confirm-btn {
            padding: 15px 50px;
            font-size: 1.4em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.1s;
            margin: 5px;
            background: var(--accent);
            color: white;
            box-shadow: 0 4px 0 #1e8449;
        }
        .confirm-btn:active { transform: translateY(4px); box-shadow: none; }
        .confirm-btn:disabled {
            background: #95a5a6;
            box-shadow: 0 4px 0 #7f8c8d;
            cursor: not-allowed;
            transform: translateY(0);
        }

        .dashboard {
            display: flex;
            justify-content: space-between;
            gap: 15px; 
            margin-bottom: 20px;
        }
        .player-stats {
            background: var(--card-bg);
            padding: 15px 20px; 
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            flex-basis: 0;
            flex-grow: 1; 
            border-top: 5px solid #bdc3c7;
            transition: all 0.3s;
            position: relative;
        }
        .player-stats.active {
            border-top-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.2);
        }
        .player-stats.weakened {
            background-color: #fff9e6;
            border-color: var(--warning);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0; 
            font-size: 1.1em; 
            align-items: center;
        }
        .money { color: var(--accent); font-weight: bold; font-family: monospace; font-size: 1.2em; }
        .total-asset { color: #e67e22; font-weight: bold; font-family: monospace; font-size: 1.2em; }
        .debt { color: var(--danger); font-weight: bold; }
        
        .hp-bar-bg { width: 100px; height: 10px; background: #ddd; border-radius: 5px; overflow: hidden; }
        .hp-bar-fill { height: 100%; transition: width 0.5s, background 0.5s; }

        .phase-indicator {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.4em; 
            font-weight: bold;
            color: #d35400;
            margin: 15px 0;
            background: #fad7a0;
            padding: 8px 15px; 
            border-radius: 5px;
        }
        .phase-center { text-align: center; flex-grow: 1; }
        #timer-display {
            font-size: 1.8em;
            color: var(--danger);
            min-width: 60px;
            text-align: right;
        }

        .cards-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .card {
            background: var(--card-bg);
            border: 3px solid #eee;
            border-radius: 8px;
            padding: 15px; 
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 180px; 
            position: relative;
            flex-basis: 0;
            flex-grow: 1; 
            flex-shrink: 1;
            min-width: 0;
        }
        .card.scam {
            border: 4px solid var(--danger);
            background: #fffafa;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.4);
        }
        .card.scam .card-title { color: var(--danger); }
        .card:hover { transform: translateY(-3px); border-color: #bdc3c7; }
        .card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.7);
            transform: translateY(-5px);
        }
        .card.scam.selected {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.7);
        }
        .card.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(1);
            cursor: not-allowed;
            border-color: #f1f1f1;
        }
        .card.force-heal {
            border-color: var(--danger);
            background: #fdf5f5;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
        }
        .card.force-heal:hover { transform: translateY(-3px); border-color: var(--danger); }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        .card-title { font-weight: bold; color: #2980b9; font-size: 1.3em; line-height: 1.2; }
        .card-desc { font-size: 1em; color: #555; line-height: 1.4; flex-grow: 1; }
        
        .tag {
            font-size: 0.8em; 
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            display: inline-block;
            margin-top: 5px;
        }
        .tag-job { background: #3498db; }
        .tag-risk-low { background: #27ae60; }
        .tag-risk-mid { background: #f39c12; }
        .tag-risk-high { background: #c0392b; }
        .tag-scam { background: #8e44ad; }
        .tag-special { background: #95a5a6; }
        .tag-special-danger { background: var(--danger); }

        .log-area {
            background: #fff;
            padding: 20px; 
            border-radius: 8px;
            height: 200px; 
            overflow-y: auto;
            border: 1px solid #ddd;
            font-family: monospace;
            font-size: 1.1em; 
        }
        .log-entry { margin-bottom: 7px; border-bottom: 1px dashed #eee; padding-bottom: 4px; }
        .log-turn { color: #fff; background: #e67e22; padding: 4px 8px; border-radius: 3px; font-weight: bold; }
        .log-bad { color: #c0392b; font-weight: bold; }
        .log-good { color: #27ae60; font-weight: bold; }
        .log-scam { color: #8e44ad; font-weight: bold; }
        .status-text { font-size: 0.9em; color: #7f8c8d; margin-top: 5px; line-height: 1.4; }
        .weakness-badge {
            background: #f39c12; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; display: none;
        }
        
        /* çµç®—å ±å‘Šè¡¨æ ¼æ¨£å¼ */
        .report-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .report-table th, .report-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .report-table th { background-color: #f2f2f2; }
    </style>
</head>
<body>

<div class="container">
    <div id="setup-screen" style="text-align: center; margin-top: 50px;">
        <h1>ğŸ¥ ç¤¾ç•œç”Ÿå­˜æˆ°ï¼šç¡¬æ ¸å¹³è¡¡ç‰ˆ v6.3</h1>
        <h3>é«˜é¢¨éšªç”Ÿå­˜ x ç†è²¡ Roguelike</h3>
        <div style="background: white; padding: 20px; border-radius: 10px; display: inline-block; text-align: left;">
            <p>âœ… <b>ç›®æ¨™ï¼š</b>20 è¼ªå¾Œç¸½è³‡ç”¢æœ€é«˜è€…ç²å‹</p>
            <p>âœ… <b>è¦å‰‡ï¼š</b>æ¯è¼ªå¾ 5 å€‹é¸é …ä¸­**é¸æ“‡ 1 æˆ– 2 å€‹**åŸ·è¡Œ</p>
            <p>ğŸ›¡ï¸ **æ–°æ‰‹ä¿è­·ï¼š** å‰ 5 è¼ªä¸æœƒå‡ºç¾è©é¨™å¡ã€‚</p>
            <p style="color: #f39c12; font-weight:bold;">âš ï¸ **è™›å¼±ç‹€æ…‹ï¼š** å¥åº· < 60ï¼Œè¡Œå‹•æ”¶ç›Šæ¸›åŠï¼</p>
            <p style="color: #c0392b; font-weight:bold;">ğŸš¨ **å´©æ½°ç‹€æ…‹ï¼š** å¥åº· <= 50ï¼Œå¼·åˆ¶ä½é™¢æ²»ç™‚ (æ¶ˆè€—æœ¬è¼ªæ‰€æœ‰è¡Œå‹•)ï¼</p>
        </div>
        <br><br>
        <button class="confirm-btn" onclick="startGame()">é–‹å§‹å°æŠ—</button>
    </div>
    
    <div id="game-screen" style="display: none;">
        <div class="phase-indicator">
            <span id="timer-display">--</span>
            <div class="phase-center">
                <span id="turn-display">æº–å‚™ä¸­...</span> | <span id="phase-msg"></span>
            </div>
        </div>

        <div class="dashboard">
            <div class="player-stats" id="p1-stats">
                <h3>ğŸ‘¨â€ğŸ’¼ A çµ„ <span class="weakness-badge" id="p1-weak-badge">è™›å¼±</span></h3>
                <div class="stat-row">
                    <span>ç¾é‡‘/å­˜æ¬¾</span>
                    <span><span class="money" id="p1-cash">$100</span> / <span class="money" id="p1-bank">$0</span></span>
                </div>
                <div class="stat-row">
                    <span>æŠ•è³‡è³‡ç”¢ (ä¼°)</span>
                    <span class="money" id="p1-investment-asset">$0</span>
                </div>
                <div class="stat-row">
                    <span>ç¸½è³‡ç”¢ (ä¼°ç®—)</span>
                    <span class="total-asset" id="p1-total-asset">$100</span>
                </div>
                <div class="stat-row">
                    <span>å¥åº·å€¼</span>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <span id="p1-hp-text">100</span>
                        <div class="hp-bar-bg"><div class="hp-bar-fill" id="p1-hp-bar" style="width:100%; background:#27ae60;"></div></div>
                    </div>
                </div>
                <div class="stat-row">åˆ©ç‡: <span class="money" style="color:#8e44ad" id="p1-rate">1.0%</span></div>
                <div class="status-text" id="p1-status">ç„¡å·¥ä½œ</div>
            </div>

            <div class="player-stats" id="p2-stats">
                <h3>ğŸ‘©â€ğŸ’» B çµ„ <span class="weakness-badge" id="p2-weak-badge">è™›å¼±</span></h3>
                <div class="stat-row">
                    <span>ç¾é‡‘/å­˜æ¬¾</span>
                    <span><span class="money" id="p2-cash">$100</span> / <span class="money" id="p2-bank">$0</span></span>
                </div>
                <div class="stat-row">
                    <span>æŠ•è³‡è³‡ç”¢ (ä¼°)</span>
                    <span class="money" id="p2-investment-asset">$0</span>
                </div>
                <div class="stat-row">
                    <span>ç¸½è³‡ç”¢ (ä¼°ç®—)</span>
                    <span class="total-asset" id="p2-total-asset">$100</span>
                </div>
                <div class="stat-row">
                    <span>å¥åº·å€¼</span>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <span id="p2-hp-text">100</span>
                        <div class="hp-bar-bg"><div class="hp-bar-fill" id="p2-hp-bar" style="width:100%; background:#27ae60;"></div></div>
                    </div>
                </div>
                <div class="stat-row">åˆ©ç‡: <span class="money" style="color:#8e44ad" id="p2-rate">1.0%</span></div>
                <div class="status-text" id="p2-status">ç„¡å·¥ä½œ</div>
            </div>
        </div>

        <div id="cards-container" class="cards-area" style="justify-content: center;"></div>

        <div class="action-area" style="text-align: center; margin-top: 20px;">
            <button class="confirm-btn" id="confirm-btn" onclick="confirmAction()" disabled>ç¢ºèªè¡Œå‹• (è«‹é¸æ“‡ 1-2 å¼µå¡)</button>
        </div>

        <h3>ğŸ“ äº‹ä»¶æ—¥èªŒ</h3>
        <div class="log-area" id="game-log"></div>
    </div>
</div>

<script>
// --- è¨­å®šèˆ‡ç‹€æ…‹å€ ---
const CONFIG = {
    maxTurns: 20,
    startCash: 100,
    livingCost: 30, 
    titheRate: 0.1, // åä¸€å¥‰ç»æ¯”ä¾‹
    baseRate: 0.01,
    startHp: 100,
    maxHp: 100,
    safeHours: 8, 
    overworkPenalty: 3, 
    // --- å¹³è¡¡æ€§èª¿æ•´ ---
    forcedHealThreshold: 50, // å¼·åˆ¶æ²»ç™‚é–€æª»
    weakThreshold: 60,       // è™›å¼±é–€æª» (æ”¶ç›Šæ¸›åŠ)
    scamStartTurn: 6,        // è©é¨™é–‹å§‹è¼ªæ•¸ (T6)
    minSickCost: 50, 
    turnSalaryIncrease: 0.02,
    scamLossRange: [1000, 3000], 
    timeLimits: [
        { endTurn: 5, time: 60 }, 
        { endTurn: 10, time: 40 }, 
        { endTurn: 15, time: 30 }, 
        { endTurn: 20, time: 20 } 
    ]
};

let gameState = {
    turn: 1,
    phase: 'p1_choice', 
    players: [],
    currentCards: [],
    selectedIndices: [], 
    maxSelections: 1,
    selectionCount: 0, 
    timer: null,
    timeLeft: 0,
    history: [] 
};

// --- å·¥å…·å‡½æ•¸å€ ---
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function log(msg, type='') {
    const area = document.getElementById('game-log');
    const div = document.createElement('div');
    div.className = 'log-entry';
    if (type === 'turn') div.innerHTML = `<span class="log-turn">${msg}</span>`;
    else if (type === 'bad') div.innerHTML = `<span class="log-bad">${msg}</span>`;
    else if (type === 'good') div.innerHTML = `<span class="log-good">${msg}</span>`;
    else if (type === 'scam') div.innerHTML = `<span class="log-scam">${msg}</span>`;
    else div.innerHTML = msg;
    area.prepend(div);
    area.scrollTop = 0;
}
function getTimeLimit(turn) {
    for (const limit of CONFIG.timeLimits) {
        if (turn <= limit.endTurn) return limit.time;
    }
    return CONFIG.timeLimits[CONFIG.timeLimits.length - 1].time;
}
function getDynamicPay(basePay) {
    if (gameState.turn === 1) return basePay;
    const increaseFactor = 1 + (gameState.turn - 1) * CONFIG.turnSalaryIncrease;
    return Math.floor(basePay * increaseFactor / 10) * 10;
}
// è¨ˆç®—æ”¶ç›Šå€ç‡ (è™›å¼±ç‹€æ…‹æ¸›åŠ)
function getIncomeMultiplier(p) {
    return (p.hp < CONFIG.weakThreshold) ? 0.5 : 1.0;
}

// --- å¡ç‰Œç”Ÿæˆå™¨å€ ---
function getCardCost(card) {
    if (card.scamCost !== undefined) return 0; 
    if (card.cost !== undefined && card.cost > 0) return card.cost;
    
    switch(card.title) {
        case 'ğŸ”’ å®šæœŸå­˜æ¬¾':
        case 'ğŸ¦ è—ç±Œè‚¡æŠ•è³‡':
        case 'ğŸš€ çŸ­æœŸæŠ•è³‡æ©Ÿæœƒ':
        case 'ğŸ“œ æ”¿åºœå…¬å‚µ':
             const match = card.desc.match(/æŠ•å…¥ \$(\d+)/) || card.desc.match(/é–å®šç¾é‡‘ \$(\d+)/);
            return match ? parseInt(match[1]) : 0;
        case 'ğŸ¤“ ç†è²¡è¬›åº§':
        case 'ğŸ§˜ æ·±åº¦ä¼‘æ¯':
        case 'ğŸ‹ï¸ å¥èº«æˆ¿æœƒå“¡':
             return card.cost; 
        default:
            return 0;
    }
}

// æ ¸å¿ƒæ‰£æ¬¾ (å„ªå…ˆæ‰£ç¾ï¼Œä¸è¶³æ‰£å­˜ï¼Œä¸å¯è² å‚µ)
function applyPayment(p, cost) {
    let actualCost = Number(cost); // ç¢ºä¿æ˜¯æ•¸å­—
    if (isNaN(actualCost) || actualCost <= 0) return 'ç„¡é ˆæ”¯ä»˜';

    if (p.cash >= actualCost) {
        p.cash -= actualCost;
        return `æˆåŠŸæ”¯ä»˜ $${actualCost} (ç¾é‡‘)`;
    } else {
        let shortage = actualCost - p.cash;
        p.cash = 0;
        if (p.bank >= shortage) {
            p.bank -= shortage;
            return `æˆåŠŸæ”¯ä»˜ $${actualCost} (ç¾é‡‘+å­˜æ¬¾)`;
        } else {
            return 'è³‡ç”¢ç¸½é¡ä¸è¶³ï¼Œäº¤æ˜“å–æ¶ˆ';
        }
    }
}
// æ ¸å¿ƒæå¤± (å¯è² å‚µ)
function applyLoss(p, loss) {
    let actualLoss = Number(loss); // ç¢ºä¿æ˜¯æ•¸å­—
    if (isNaN(actualLoss) || actualLoss <= 0) return 0;
    
    if (p.cash >= actualLoss) {
        p.cash -= actualLoss;
    } else {
        let shortage = actualLoss - p.cash;
        p.cash = 0;
        p.bank -= shortage;
    }
    return actualLoss;
}

const generators = {
    // å·¥ä½œ (å—è™›å¼±å½±éŸ¿)
    jobStableStandard: () => {
        const basePay = 200; const pay = getDynamicPay(basePay);
        return { title: 'ğŸ’¼ ä¸€èˆ¬è·å“¡', tag: 'ç©©å®šå·¥ä½œ', desc: `æ¨™æº–å·¥æ™‚ **8 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`, effect: (p) => { p.stableJob = { name: 'ä¸€èˆ¬è·å“¡', pay: pay, hours: 8 }; return 'ç²å¾—ç©©å®šå·¥ä½œ'; } };
    },
    jobStableShift: () => {
        const basePay = 300; const pay = getDynamicPay(basePay);
        return { title: 'ğŸ­ ç”¢ç·šä½œæ¥­å“¡', tag: 'åšäºŒä¼‘äºŒ', desc: `æ¯æ—¥ **10 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`, effect: (p) => { p.stableJob = { name: 'ä½œæ¥­å“¡', pay: pay, hours: 10 }; return 'ç²å¾—é«˜å·¥æ™‚å·¥ä½œ'; } };
    },
    jobStableOvertime: () => {
        const basePay = 450; const pay = getDynamicPay(basePay);
        return { title: 'ğŸ’» è²¬ä»»åˆ¶å·¥ç¨‹å¸«', tag: 'çˆ†è‚', desc: `æ¯æ—¥ **12 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`, effect: (p) => { p.stableJob = { name: 'å·¥ç¨‹å¸«', pay: pay, hours: 12 }; return 'ç²å¾—çˆ†è‚å·¥ä½œ'; } };
    },
    jobStableLow: () => {
        const basePay = 150; const pay = getDynamicPay(basePay);
        return { title: 'ğŸ›’ ä¾¿åˆ©å•†åº—åº—å“¡', tag: 'ä½è–ª', desc: `æ¨™æº–å·¥æ™‚ **8 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`, effect: (p) => { p.stableJob = { name: 'åº—å“¡', pay: pay, hours: 8 }; return 'ç²å¾—ä½è–ªå·¥ä½œ'; } };
    },
    jobStableMed: () => {
        const basePay = 250; const pay = getDynamicPay(basePay);
        return { title: 'ğŸ‘¨â€ğŸ« è£œç¿’ç­è€å¸«', tag: 'ä¸­è–ª', desc: `æ¯æ—¥ **9 å°æ™‚**ã€‚æ¯è¼ªæ”¶å…¥ $${pay}ã€‚`, effect: (p) => { p.stableJob = { name: 'è€å¸«', pay: pay, hours: 9 }; return 'ç²å¾—ä¸­ç­‰å·¥ä½œ'; } };
    },
    jobPartTime: () => {
        const turnsLeft = CONFIG.maxTurns - gameState.turn;
        const hours = randInt(2, 4);
        const basePay = hours * randInt(20, 30); const pay = getDynamicPay(basePay);
        const turns = randInt(3, Math.min(5, turnsLeft));
        if (turns <= 0) return generators.rest({sicknessCost: 0});
        return { title: 'ğŸ›µ å¤–é€å…¼è·', tag: 'å…¼è·', desc: `æ¯è¼ª +$${pay} (${hours}hr)ï¼ŒæŒçºŒ ${turns} è¼ªã€‚`, effect: (p) => { p.partTimeJobs.push({ name: 'å¤–é€', pay: pay, hours: hours, turnsLeft: turns }); return 'é–‹å§‹å…¼è·'; } };
    },
    
    // å³æ™‚æ”¶å…¥ (å—è™›å¼±å½±éŸ¿)
    gigEconomy: () => {
        const basePay = 40; const hours = 2;
        return { title: 'ğŸ§¹ é€±æœ«é›¶å·¥', tag: 'è‡¨æ™‚å·¥', desc: `ç«‹å³ç²å¾— $${basePay}ï¼Œå·¥æ™‚ ${hours}hrã€‚`, 
            effect: (p) => { 
                const mult = getIncomeMultiplier(p);
                const actualPay = Math.floor(basePay * mult);
                p.cash += actualPay; 
                let msg = `æ‰“é›¶å·¥è³ºå– $${actualPay}`;
                if(mult < 1) msg += ` (âš ï¸è™›å¼±)`;
                return msg; 
            } 
        };
    },
    bonusCash: () => { const b = randInt(50, 100); return { title: 'ğŸ‰ å°ç¢ºå¹¸ç´…åŒ…', tag: 'é¡å¤–æ”¶å…¥', desc: `ç²å¾— $${b} ç¾é‡‘ã€‚`, effect: (p) => { const m = getIncomeMultiplier(p); const ab = Math.floor(b*m); p.cash += ab; return `ç²å¾— $${ab} ${m<1?'(âš ï¸è™›å¼±)':''}`; } }; },
    bonusAnnual: () => { const b = randInt(150, 300); return { title: 'ğŸ å¹´åº¦åˆ†ç´…', tag: 'ç‰¹æ®Šæ”¶å…¥', desc: `ç²å¾— $${b} çé‡‘ã€‚`, effect: (p) => { const m = getIncomeMultiplier(p); const ab = Math.floor(b*m); p.cash += ab; return `ç²å¾— $${ab} ${m<1?'(âš ï¸è™›å¼±)':''}`; } }; },
    
    // æ”¯å‡ºèˆ‡æŠ•è³‡
    gymMembership: () => {
        const cost = 30; const hpGain = 10;
        return { title: 'ğŸ‹ï¸ å¥èº«æˆ¿æœƒå“¡', tag: 'å¥åº·', cost: cost, desc: `èŠ±è²» $${cost} é›éŠï¼Œæå‡ ${hpGain} é»å¥åº·å€¼ã€‚`, 
            effect: (p) => { const result = applyPayment(p, cost); if (result.includes('æˆåŠŸ')) p.hp = Math.min(CONFIG.maxHp, p.hp + hpGain); return `å¥èº« +${hpGain} HP (${result})`; } 
        };
    },
    govBond: () => {
        const cost = 100; const returnAmt = 110; const turns = 3;
        return { title: 'ğŸ“œ æ”¿åºœå…¬å‚µ', tag: 'ä½é¢¨éšª', cost: cost, desc: `æŠ•å…¥ $${cost}ï¼Œ${turns} è¼ªå¾Œä¿è­‰å›æ”¶ $${returnAmt}ã€‚`, effect: (p) => { const r = applyPayment(p, cost); if (r.includes('æˆåŠŸ')) p.investments.push({ cost: cost, returnFixed: returnAmt, turnsLeft: turns, name: 'å…¬å‚µ' }); return `è³¼è²·å…¬å‚µ (${r})`; } };
    },
    depositFlexible: () => ({ 
        title: 'ğŸ’° å½ˆæ€§å­˜æ¬¾', 
        tag: 'æ´»æœŸå­˜æ¬¾', 
        desc: `å­˜å…¥ä»»æ„æ¯”ä¾‹ç¾é‡‘ (é»æ“Šè¼¸å…¥)ã€‚`, 
        effect: (p, a) => { 
            let amt = Number(a);
            if (isNaN(amt) || amt <= 0) return 'å­˜æ¬¾å¤±æ•— (é‡‘é¡ç„¡æ•ˆ)';
            p.cash -= amt; p.bank += amt; 
            return `å­˜å…¥ $${amt}`; 
        } 
    }),
    depositFixed: () => {
        const turnsLeft = CONFIG.maxTurns - gameState.turn;
        const cost = randInt(100, 300);
        const turns = randInt(4, Math.min(8, turnsLeft));
        if (turns <= 0) return generators.depositFlexible();
        const rate = randInt(5, 10)/1000;
        return { title: 'ğŸ”’ å®šæœŸå­˜æ¬¾', tag: 'ç©©å®šç†è²¡', cost: cost, desc: `é–å®š $${cost}ï¼Œ${turns} è¼ªå¾Œé ˜å›æœ¬åˆ©ã€‚`, effect: (p) => { const r = applyPayment(p, cost); if(r.includes('æˆåŠŸ')) p.lockedSavings.push({cost, turnsLeft: turns, totalReturnRate: 1+rate*turns}); return r; } };
    },
    rateBoostLong: () => {
        const v = randInt(15, 40)/1000; const t = 3;
        return { title: 'ğŸ¦ åŠ æ¯æ´»å‹•', tag: 'ç‰¹æ®Š', desc: `æœªä¾† ${t} è¼ªåˆ©ç‡ +${(v*100).toFixed(1)}%ã€‚`, effect: (p) => { p.tempRateBoost = {amount:v, turnsLeft:t}; return 'åˆ©ç‡æå‡'; } };
    },
    financialSeminar: () => {
        const v = randInt(10, 25)/1000; const t = 5; const c = 20;
        return { title: 'ğŸ¤“ ç†è²¡è¬›åº§', tag: 'ä»˜è²»ç‰¹æ®Š', cost: c, desc: `èŠ±è²» $${c}ï¼Œåˆ©ç‡ +${(v*100).toFixed(1)}% (${t}è¼ª)ã€‚`, effect: (p) => { const r = applyPayment(p, c); if(r.includes('æˆåŠŸ')) p.tempRateBoost = {amount:v, turnsLeft:t}; return r; } };
    },
    invest: () => {
        const tl = CONFIG.maxTurns - gameState.turn;
        const r = randInt(10, 100);
        const c = randInt(50, 100);
        const w = randInt(2, Math.min(4, tl));
        if(w <= 0) return generators.rest({sicknessCost:0});
        return { title: 'ğŸš€ çŸ­æœŸæŠ•è³‡', tag: 'é¢¨éšª', cost: c, desc: `æŠ•å…¥ $${c}ï¼Œ${w} è¼ªå¾Œçµç®— (é¢¨éšª ${r})ã€‚`, effect: (p) => { const res = applyPayment(p, c); if(res.includes('æˆåŠŸ')) p.investments.push({cost:c, maxRoi: 120+Math.floor(r*1.5), risk:r, turnsLeft:w}); return res; } };
    },
    investStock: () => {
        let c; if (gameState.turn <= 4) c = randInt(100, 250); else c = randInt(300, 500);
        return { title: 'ğŸ¦ è—ç±Œè‚¡', tag: 'é•·æœŸ', cost: c, desc: `æŠ•å…¥ $${c}ï¼Œæ¯è¼ªé ˜è‚¡åˆ©ã€‚`, effect: (p) => { const r = applyPayment(p, c); if(r.includes('æˆåŠŸ')) p.stocks.push({cost:c, name:'è—ç±Œè‚¡'}); return r; } };
    },

    // ä¼‘æ¯ (v6.0 ç¡¬æ ¸ç‰ˆï¼šè²»ç”¨å¢åŠ )
    rest: (p) => {
        const baseCost = 60; 
        const totalCost = baseCost + p.sicknessCost; 
        const healAmt = 20; 
        return { title: 'ğŸ§˜ æ·±åº¦ä¼‘æ¯', tag: 'æ²»ç™‚', cost: totalCost, desc: `èŠ±è²» $${totalCost} (å«é†«ç™‚è²»)ï¼Œæ¢å¾© ${healAmt} HPã€‚`, 
            effect: (p) => { 
                const r = applyPayment(p, totalCost); 
                if(r.includes('æˆåŠŸ')) { p.hp = Math.min(CONFIG.maxHp, p.hp + healAmt); p.sicknessCost = 0; } 
                return r; 
            } 
        };
    },

    // è©é¨™
    scamCrypto: () => ({ title: 'ğŸ’¥ é£†å‡å¹£', tag: 'è©é¨™', scamCost: true, desc: 'æŠ•è³‡è™›æ“¬å¹£ï¼Ÿ(é«˜é¢¨éšª)', effect: (p) => { const l = randInt(CONFIG.scamLossRange[0], CONFIG.scamLossRange[1]); const al = applyLoss(p, l); p.hp-=5; return `è©é¨™æå¤± $${al}`; } }),
    scamSocial: () => ({ title: 'âŒ åœ‹å¤–é«˜è–ª', tag: 'è©é¨™', scamCost: true, desc: 'åœ‹å¤–å·¥ä½œæ©Ÿæœƒï¼Ÿ(é«˜é¢¨éšª)', effect: (p) => { const l = randInt(CONFIG.scamLossRange[0], CONFIG.scamLossRange[1]); const al = applyLoss(p, l); p.hp-=10; return `è©é¨™æå¤± $${al}`; } }),
    scamInsurance: () => ({ title: 'ğŸ’¸ é«˜å ±é…¬ä¿å–®', tag: 'æ¨éŠ·', scamCost: true, desc: 'å¼·è¿«æ¨éŠ·ä¿å–®ï¼Ÿ', effect: (p) => { const l = randInt(CONFIG.scamLossRange[0], CONFIG.scamLossRange[1]); const al = applyLoss(p, l); return `æ¨éŠ·æå¤± $${al}`; } }),
};

// --- é‚è¼¯æ§åˆ¶å€ ---

function createPlayer(name) {
    return { name, id: name === 'A çµ„' ? 0 : 1, cash: CONFIG.startCash, bank: 0, rate: CONFIG.baseRate, tempRateBoost: { amount: 0, turnsLeft: 0 }, hp: CONFIG.startHp, stableJob: null, partTimeJobs: [], investments: [], lockedSavings: [], stocks: [], roundIncome: 0, sicknessCost: 0 };
}

function startGame() {
    document.getElementById('setup-screen').style.display = 'none';
    document.getElementById('game-screen').style.display = 'block';
    gameState.turn = 1; gameState.players = [createPlayer('A çµ„'), createPlayer('B çµ„')];
    log("=== éŠæˆ²é–‹å§‹ ===", 'turn');
    startPlayerTurn(0);
}

function startTimer(duration) {
    clearInterval(gameState.timer);
    gameState.timeLeft = duration;
    document.getElementById('timer-display').innerText = gameState.timeLeft;
    gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        document.getElementById('timer-display').innerText = gameState.timeLeft;
        if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timer);
            confirmAction(false, true);
        }
    }, 1000);
}

function startPlayerTurn(playerIdx) {
    if (gameState.turn > CONFIG.maxTurns) { endGame(); return; }
    gameState.phase = playerIdx === 0 ? 'p1_choice' : 'p2_choice';
    gameState.selectedIndices = []; gameState.selectionCount = 0;
    gameState.maxSelections = (gameState.turn === 1) ? 1 : 2;
    updateUI(); generateCards(playerIdx);
    document.getElementById('confirm-btn').disabled = true;
    document.getElementById('confirm-btn').innerText = `ç¢ºèªè¡Œå‹• (è«‹é¸æ“‡ 1-${gameState.maxSelections} å¼µå¡)`;
    startTimer(getTimeLimit(gameState.turn));
}

function generateCards(playerIdx) {
    let pool = [];
    const player = gameState.players[playerIdx];

    if (gameState.turn === 1) {
        const t1 = [generators.jobStableStandard, generators.jobStableShift, generators.jobStableOvertime, generators.jobStableLow, generators.jobStableMed];
        gameState.currentCards = t1.sort(() => 0.5 - Math.random()).map(g => g());
    } else {
        pool = [
            generators.jobStableStandard, generators.jobStableShift, 
            ...(gameState.turn <= CONFIG.maxTurns - 5 ? [generators.jobStableOvertime] : []),
            generators.jobPartTime, generators.jobPartTime, generators.gigEconomy, generators.gigEconomy, 
            generators.bonusCash, generators.bonusAnnual, generators.financialSeminar,
            generators.depositFlexible, generators.rateBoostLong, generators.depositFixed, generators.govBond,
            generators.invest, generators.invest, generators.investStock,
            generators.gymMembership, 
            () => generators.rest(player), () => generators.rest(player)
        ];
        if (gameState.turn >= CONFIG.scamStartTurn) {
             pool.push(generators.scamCrypto, generators.scamSocial, generators.scamInsurance);
        }

        let uniqueDeck = []; let titles = new Set(); let attempts = 0;
        while(uniqueDeck.length < 5 && attempts < 100) {
            let card = pool[Math.floor(Math.random() * pool.length)]();
            if (card && !titles.has(card.title)) { titles.add(card.title); uniqueDeck.push(card); }
            attempts++;
        }
        gameState.currentCards = uniqueDeck;
    }
    
    // å¼·åˆ¶æ²»ç™‚æª¢æŸ¥
    if (player.hp <= CONFIG.forcedHealThreshold) {
        let restCard = generators.rest(player);
        const restIndex = gameState.currentCards.findIndex(c => c.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯');
        if (restIndex === -1) {
             // å¦‚æœç‰Œçµ„ä¸­æ²’æœ‰ï¼Œå‰‡æ›¿æ›ç¬¬ä¸€å¼µå¡ç‰‡
             gameState.currentCards[0] = restCard;
        } else {
            // å¦‚æœæœ‰ï¼Œå‰‡æ›´æ–°æˆæœ¬
            gameState.currentCards[restIndex] = restCard;
        }
    }
    renderCards();
}

function renderCards() {
    const container = document.getElementById('cards-container');
    container.innerHTML = '';
    const player = gameState.players[gameState.phase.startsWith('p1') ? 0 : 1];
    const totalAsset = player.cash + player.bank;
    const isForceHealing = player.hp <= CONFIG.forcedHealThreshold;

    gameState.currentCards.forEach((card, idx) => {
        let div = document.createElement('div');
        let isScam = card.scamCost !== undefined;
        div.className = `card ${isScam ? 'scam' : ''}`; div.id = `card-${idx}`;
        
        let tagClass = 'tag-special';
        if (card.tag.includes('é¢¨éšª')) tagClass = 'tag-risk-low';
        else if (card.tag.includes('å·¥ä½œ')) tagClass = 'tag-job';
        else if (isScam) tagClass = 'tag-scam';

        let clickText = (card.title === 'ğŸ’° å½ˆæ€§å­˜æ¬¾') ? 'é»æ“Šè¼¸å…¥' : 'é»æ“Šé¸æ“‡';
        const cost = getCardCost(card);
        let isDisabled = false;

        // è³‡ç”¢æª¢æŸ¥ (è©é¨™ä¸æª¢æŸ¥)
        if (cost > 0 && cost > totalAsset && card.title !== 'ğŸ’° å½ˆæ€§å­˜æ¬¾' && !isScam) isDisabled = true;
        
        // å¼·åˆ¶æ²»ç™‚æª¢æŸ¥
        if (isForceHealing) {
            if (card.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯') {
                if (isDisabled) {
                    // å¦‚æœé€£æ²»ç™‚éƒ½ä»˜ä¸èµ·
                    div.classList.add('disabled');
                    clickText = `ğŸš¨ æ²»ç™‚å¤±æ•— (è³‡ç”¢ä¸è¶³)`;
                } else {
                    div.classList.add('force-heal');
                    clickText = `ğŸš¨ å¿…é ˆæ²»ç™‚ $${card.cost}`;
                }
            } else {
                isDisabled = true;
            }
        }

        if (isDisabled) div.classList.add('disabled');
        if (gameState.selectedIndices.includes(idx)) div.classList.add('selected');

        div.innerHTML = `<div><div class="card-header"><div class="card-title">${card.title}</div><span class="tag ${tagClass}">${card.tag}</span></div><div class="card-desc">${card.desc}</div></div><small>${isDisabled ? 'æ¢ä»¶ä¸ç¬¦' : clickText}</small>`;
        
        if (!isDisabled) div.onclick = () => handleCardClick(idx);
        container.appendChild(div);
    });
}

function handleCardClick(index) {
    const btn = document.getElementById('confirm-btn');
    const cardElement = document.getElementById(`card-${index}`);
    const card = gameState.currentCards[index];
    const playerIdx = gameState.phase.startsWith('p1') ? 0 : 1;
    const player = gameState.players[playerIdx];

    // å¼·åˆ¶æ²»ç™‚ï¼šé»æ“Šå³é¸å®šä¸¦å˜—è©¦åŸ·è¡Œ
    if (player.hp <= CONFIG.forcedHealThreshold) {
        if (card.title === 'ğŸ§˜ æ·±åº¦ä¼‘æ¯') { 
            // è¦–ç‚º Quick Actionï¼Œæ¸…ç©ºå…¶ä»–é¸æ“‡
            gameState.selectedIndices = [index]; 
            // å¼·åˆ¶æ¶ˆè€—æœ¬è¼ªæ‰€æœ‰è¡Œå‹•é»æ•¸ï¼Œç›´æ¥ç¢ºèª
            confirmAction(true); 
        }
        return;
    }

    // å­˜æ¬¾
    if (card.title === 'ğŸ’° å½ˆæ€§å­˜æ¬¾') {
        if (gameState.selectionCount + gameState.selectedIndices.length >= gameState.maxSelections) return;
        clearInterval(gameState.timer);
        let input = prompt("è¼¸å…¥å­˜æ¬¾æ¯”ä¾‹ï¼š20/50/ALL (æˆ–è¼¸å…¥å¯¦éš›é‡‘é¡)");
        startTimer(gameState.timeLeft);
        if (input) {
             let amt = 0;
             if (input.toUpperCase() === 'ALL') amt = player.cash;
             else if (input === '20') amt = Math.floor(player.cash * 0.2);
             else if (input === '50') amt = Math.floor(player.cash * 0.5);
             else if (!isNaN(Number(input))) amt = Math.min(Number(input), player.cash);
             
             amt = Math.floor(amt); // ç¢ºä¿æ˜¯æ•´æ•¸

             if (amt > 0) {
                 const result = card.effect(player, amt);
                 log(result, 'good');
                 gameState.selectionCount++;
                 recordHistory(player, [card.title]); // ç«‹å³è¨˜éŒ„
                 updateUI();
                 cardElement.classList.add('disabled'); cardElement.onclick = null;
                 checkSelectionStatus(btn);
             } else {
                 log('å­˜æ¬¾é‡‘é¡ç„¡æ•ˆæˆ–ç¾é‡‘ä¸è¶³', 'bad');
             }
        }
        return;
    }

    // è©é¨™
    if (card.scamCost) {
        if (gameState.selectionCount + gameState.selectedIndices.length >= gameState.maxSelections) return;
        
        // åŸ·è¡Œæ•ˆæœä¸¦è¨˜éŒ„
        log(card.effect(player), 'scam');
        recordHistory(player, [card.title]);
        
        gameState.selectionCount++;
        updateUI();
        cardElement.classList.add('disabled'); cardElement.onclick = null;
        checkSelectionStatus(btn);
        return;
    }

    // ä¸€èˆ¬
    const idx = gameState.selectedIndices.indexOf(index);
    if (idx > -1) { gameState.selectedIndices.splice(idx, 1); cardElement.classList.remove('selected'); }
    else {
        if (gameState.selectionCount + gameState.selectedIndices.length < gameState.maxSelections) {
            gameState.selectedIndices.push(index); cardElement.classList.add('selected');
        }
    }
    checkSelectionStatus(btn);
}

function checkSelectionStatus(btn) {
    const total = gameState.selectionCount + gameState.selectedIndices.length;
    // å¦‚æœå› ç‚º Quick Action (å­˜æ¬¾/è©é¨™) å°è‡´è¡Œå‹•æ•¸æ»¿äº†ï¼Œç›´æ¥åŸ·è¡Œ
    if (total >= gameState.maxSelections && gameState.selectedIndices.length === 0) {
         confirmAction(true);
    } else if (total > 0 && total <= gameState.maxSelections) {
        btn.disabled = false; btn.innerText = `ç¢ºèªè¡Œå‹• (${total}/${gameState.maxSelections})`;
    } else {
        btn.disabled = true; btn.innerText = `ç¢ºèªè¡Œå‹• (${total}/${gameState.maxSelections})`;
    }
}

function confirmAction(isQuickAction = false) {
    clearInterval(gameState.timer);
    const playerIdx = gameState.phase.startsWith('p1') ? 0 : 1;
    const player = gameState.players[playerIdx];
    
    let actions = [];
    gameState.selectedIndices.forEach(idx => {
        const card = gameState.currentCards[idx];
        log(`[${card.title}] ${card.effect(player)}`);
        actions.push(card.title);
    });
    
    if (actions.length > 0) recordHistory(player, actions);
    
    gameState.selectedIndices = [];
    if (playerIdx === 0) startPlayerTurn(1);
    else {
        gameState.phase = 'processing';
        document.getElementById('cards-container').innerHTML = '<h3 style="text-align:center;">çµç®—ä¸­...</h3>';
        setTimeout(processTurn, 500);
    }
}

function processTurn() {
    log(`--- ç¬¬ ${gameState.turn} è¼ªçµç®— ---`, 'turn');
    handleGlobalEvents();
    
    gameState.players.forEach(p => {
        let logs = [];
        p.roundIncome = 0; // é‡ç½®æœ¬è¼ªæ”¶å…¥
        const multiplier = getIncomeMultiplier(p);

        // å·¥æ™‚å¥åº·
        let dailyHours = 0;
        if (p.stableJob) dailyHours += p.stableJob.hours;
        p.partTimeJobs.forEach(j => dailyHours += j.hours);
        if (dailyHours > CONFIG.safeHours) {
            let dmg = (dailyHours - CONFIG.safeHours) * CONFIG.overworkPenalty;
            p.hp -= dmg;
            logs.push(`éå‹(${dailyHours}hr) å¥åº·-${dmg}`);
        }
        // ç—…å‚µ
        if (p.hp < 100 && p.sicknessCost === 0 && Math.random() < (100-p.hp)*0.007) {
            p.sicknessCost = CONFIG.minSickCost; logs.push(`ğŸ¤’ å…ç–«åŠ›ä½ä¸‹ï¼Œç´¯ç©é†«ç™‚è²»$${p.sicknessCost}`);
        } else if (p.sicknessCost > 0) {
             p.sicknessCost += randInt(10, 50); p.hp -= 3; logs.push(`ğŸš¨ ç—…æƒ…æƒ¡åŒ–ï¼Œé†«ç™‚è²»ç´¯è¨ˆ$${p.sicknessCost}`);
        }
        
        // æ”¶å…¥ - 1. å·¥ä½œæ”¶å…¥ (è¨ˆç®—é€² roundIncome)
        if (p.stableJob) {
            let pay = Math.floor(p.stableJob.pay * multiplier);
            p.cash += pay; p.roundIncome += pay;
        }
        p.partTimeJobs.forEach(j => {
            let pay = Math.floor(j.pay * multiplier);
            p.cash += pay; p.roundIncome += pay; j.turnsLeft--;
        });
        p.partTimeJobs = p.partTimeJobs.filter(j => j.turnsLeft > 0);
        
        // æ”¶å…¥ - 2. è‚¡åˆ© (è¨ˆç®—é€² roundIncome)
        p.stocks.forEach(s => {
            let div = Math.floor(randInt(8, 15) * Math.floor(s.cost/100));
            p.cash += div; p.roundIncome += div;
        });

        // çµç®— - 3. åˆ©æ¯ (è¨ˆç®—é€² roundIncome)
        if (p.bank > 0) {
            let r = CONFIG.baseRate + (p.tempRateBoost.turnsLeft > 0 ? p.tempRateBoost.amount : 0);
            if (p.tempRateBoost.turnsLeft > 0) p.tempRateBoost.turnsLeft--;
            let int = Math.floor(p.bank * r);
            p.bank += int; p.roundIncome += int;
        }

        // æ”¯å‡º - 1. åä¸€å¥‰ç» (åŸºæ–¼ roundIncome)
        let tithe = Math.floor(p.roundIncome * CONFIG.titheRate);
        if (tithe > 0) {
            applyLoss(p, tithe);
            logs.push(`ğŸ™ åä¸€å¥‰ç» -$${tithe}`);
        }

        // æ”¯å‡º - 2. ç”Ÿæ´»è²»ç”¨
        let livingCost = CONFIG.livingCost;
        applyLoss(p, livingCost);
        logs.push(`ğŸ›’ ç”Ÿæ´»è²»ç”¨ -$${livingCost}`);
        
        // æŠ•è³‡/å®šå­˜
        p.investments = p.investments.filter(i => {
            i.turnsLeft--;
            if (i.turnsLeft === 0) {
                let roll = Math.random() * 100;
                if (roll < i.risk/2.5) {
                    let loss = Math.floor(i.cost * (randInt(10, 50 + i.risk/2)/100));
                    p.cash += (i.cost - loss);
                    logs.push(`æŠ•è³‡å¤±åˆ© è™§æ$${loss}`);
                } else {
                    let profit = Math.floor(i.cost * (randInt(10, i.maxRoi-100)/100));
                    p.cash += (i.cost + profit); p.roundIncome += profit;
                    logs.push(`æŠ•è³‡ç²åˆ© +$${profit}`);
                }
                return false;
            }
            return true;
        });
        // å®šå­˜
        p.lockedSavings = p.lockedSavings.filter(l => {
            l.turnsLeft--;
            if (l.turnsLeft === 0) {
                let ret = Math.floor(l.cost * l.totalReturnRate);
                p.cash += ret; p.roundIncome += (ret - l.cost);
                logs.push(`å®šå­˜åˆ°æœŸ +$${ret}`);
                return false;
            }
            return true;
        });

        if (p.hp < 0) p.hp = 0;
        if (logs.length) log(`${p.name}: ${logs.join(' | ')}`);
    });

    gameState.turn++;
    if (gameState.turn > CONFIG.maxTurns) endGame();
    else startPlayerTurn(0);
}

function handleGlobalEvents() {
    if (gameState.turn > 5 && Math.random() < 0.4) {
        const evts = [
            {t:'ç¨…å–®', a:30}, {t:'å¸³å–®', a:25}, {t:'ç½°å–®', a:50}, {t:'æ’¿åˆ°éŒ¢', a:-20}, {t:'ä¸­ç', a:-80}
        ];
        let e = evts[randInt(0, evts.length-1)];
        log(`[éš¨æ©Ÿ] ${e.t} ${e.a>0?'-':'+'}$${Math.abs(e.a)}`);
        gameState.players.forEach(p => { 
            if(e.a>0) applyLoss(p, e.a); 
            else p.cash+=Math.abs(e.a); 
        });
    }
}

// è¨˜éŒ„æ­·å² (ç¢ºä¿åŒ…å« Quick Action çš„å¡ç‰‡)
function recordHistory(player, actions) {
    const asset = getAssets(player, true);
    gameState.history.push({
        turn: gameState.turn,
        player: player.name,
        cash: player.cash,
        bank: player.bank,
        totalAsset: asset,
        hp: Math.floor(player.hp),
        sicknessCost: player.sicknessCost,
        stableJob: player.stableJob ? player.stableJob.name : 'ç„¡',
        partTimeCount: player.partTimeJobs.length,
        actions: actions.join(';')
    });
}

// è¶£å‘³çµ±è¨ˆ
function getFunStats() {
    const counts = {};
    gameState.history.forEach(h => {
        h.actions.split(';').forEach(a => {
            if (a) counts[a] = (counts[a] || 0) + 1;
        });
    });
    return Object.entries(counts).sort((a,b) => b[1]-a[1]).slice(0, 5);
}

function updateUI() {
    document.getElementById('turn-display').innerText = `ç¬¬ ${gameState.turn} / ${CONFIG.maxTurns} è¼ª`;
    updatePlayerUI(0, 'p1'); updatePlayerUI(1, 'p2');
    document.getElementById('p1-stats').classList.toggle('active', gameState.phase.startsWith('p1'));
    document.getElementById('p2-stats').classList.toggle('active', gameState.phase.startsWith('p2'));
}
function updatePlayerUI(idx, prefix) {
    const p = gameState.players[idx];
    const el = (id) => document.getElementById(`${prefix}-${id}`);
    el('cash').innerText = `$${p.cash}`; el('bank').innerText = `$${p.bank}`;
    el('investment-asset').innerText = `$${getAssets(p, false, true)}`;
    el('total-asset').innerText = `$${getAssets(p, true)}`;
    el('hp-text').innerText = Math.floor(p.hp) + (p.sicknessCost>0?` (ç—…$${p.sicknessCost})`:'');
    el('hp-bar').style.width = `${p.hp}%`;
    el('hp-bar').style.background = p.hp < CONFIG.forcedHealThreshold ? '#e74c3c' : (p.hp < CONFIG.weakThreshold ? '#f39c12' : '#27ae60');
    el('status').innerText = p.stableJob ? p.stableJob.name : 'ç„¡';
    
    // è™›å¼±æ¨™è¨˜
    const badge = document.getElementById(`${prefix}-weak-badge`);
    if (badge) badge.style.display = p.hp < CONFIG.weakThreshold ? 'inline-block' : 'none';
    document.getElementById(`${prefix}-stats`).classList.toggle('weakened', p.hp < CONFIG.weakThreshold);
}
function getAssets(p, incCash, onlyInv) {
    let v = 0;
    p.investments.forEach(i => v += Math.floor(i.cost*0.5));
    p.lockedSavings.forEach(i => v += i.cost);
    p.stocks.forEach(s => v += s.cost);
    if (onlyInv) return v;
    if (incCash) v += (p.cash + p.bank);
    return v;
}
function endGame() {
    clearInterval(gameState.timer);
    const p1 = getAssets(gameState.players[0], true);
    const p2 = getAssets(gameState.players[1], true);
    const win = p1 > p2 ? "ğŸ† A çµ„ç²å‹" : "ğŸ† B çµ„ç²å‹";
    
    // æœ€çµ‚å ±å‘Š
    let report = `<div style="background:#fdf6e3;padding:15px;margin-top:15px;border-radius:5px;text-align:left;">
        <h3 style="text-align:center;color:#e67e22;">ğŸ“Š æœ€çµ‚çµç®—</h3>`;
        
    gameState.players.forEach(p => {
        const total = getAssets(p, true);
        const inv = getAssets(p, false, true);
        report += `<div style="margin-bottom:10px;border-left:4px solid ${p.id===0?'#3498db':'#27ae60'};padding-left:10px;">
            <strong>${p.name}</strong> (HP: ${Math.floor(p.hp)})<br>
            ç¸½è³‡ç”¢: <span class="total-asset">$${total}</span> | æŠ•è³‡: $${inv}<br>
            ç¾é‡‘/æ´»å­˜: ${Math.floor(p.cash)} / ${Math.floor(p.bank)}<br>
            æœ€å¾Œå·¥ä½œ: ${p.stableJob ? p.stableJob.name : 'ç„¡'}
        </div>`;
    });
    
    // è¶£å‘³çµ±è¨ˆ
    const topCards = getFunStats();
    report += `<hr><h4>ğŸ”¥ ç†±é–€é¸æ“‡ Top 5</h4><ul>`;
    topCards.forEach(c => report += `<li>${c[0]}: ${c[1]} æ¬¡</li>`);
    report += `</ul></div>`;

    document.getElementById('cards-container').innerHTML = `
        <div style="background:white;padding:20px;text-align:center;">
            <h1>${win}</h1>
            ${report}
            <button class="confirm-btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
        </div>`;
}
</script>
</body>
</html>
